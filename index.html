<!DOCTYPE html>
<html lang="en">
<head>
	<link href="//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!--<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>-->
</head>
<body>
<div class="container">
	<div class="page-header">
	  <h1>Stanford CS193p<small> Developing Applications for iOS Fall 2013-14</small></h1>
	</div>

	<div class="row">
		<div class="col-md-10"><h3>Lecture 1. Class Logistics, Overview of iOS, MVC, Objective-C</h3></div>
		<div class="col-md-2">
	        <ul class="nav nav-pills">
	          <li><a href="Lecture 1 Slides.pdf">Slides</a></li>
	          <li><a href="http://a984.phobos.apple.com/us/r30/CobaltPublic6/v4/f5/43/ab/f543ab3b-a490-eef1-06fd-c5b23bc5d5b1/335-8860929064720897726-01_9_23_13_Mon_720p1500cc.mp4">Lecture</a></li>
	        </ul>
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
			<p>Model = What your application is (but not how it is displayed)</p>
			<p>Controller = How your Model is presented to the user (UI logic)</p>
			<p>View = Your Controllers minions</p>
			<p>Controllers can always talk directly to their Model.<p>
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
			<pre><span class="small">00:00 [ Music ]
00:05 >> Stanford University.
00:09 >> Alright, so welcome to Stanford CS193p, fall of 2013-14 academic year.
00:14 This is our very first lecture and we are going to be covering developing applications for iOS, so specifically iOS7.
00:22 Today's lecture kind of has a first part and a second part.
00:26 The first part is a little bit of logistics.
00:28 The second part is I'm going to dive right into the course material because there's a lot to cover and so, we need to start covering it.
00:36 [Pause] So, what will I learn in this course?
00:38 I think you know what you're going to learn in this course.
00:40 You're going to learn how to build cool apps, okay?
00:42 iOS is a really cool platform for building apps, you probably already know that.
00:47 The apps look cool, they've got animation.
00:51 What's really cool is they're in your pockets so you can whip them out and show them to your friends.
00:55 You don't have to send them to a website or go get a computer.
00:57 It's also really easy to develop really powerful apps in a really short amount of time, as you're going to find.
01:03 This course is only 10 weeks long, and while this is Stanford, I know, you're all really, really good programmers and all that, it still, 10 weeks is not a lot of time, so when we get to the end, you're going to see that it's a very leveraged platform for building things.
01:17 And, you know, the community is quite vibrant, being able to distribute your apps via the app store and not have to put them in a box and put them on a shelf in a store, is really a big, big difference when it comes to marketing a product.
01:30 Okay? And you'll, you'll see that.
01:32 The second thing you're going to learn in this course though is real-world application, a lot of the computer science things you're learning in other classes.
01:39 Okay? So, we're going to be doing networking, we're going to do multithreaded, we're going to be doing all kinds of graphics, we're going to be doing animation, we're going to do object-oriented databases, we're going to do all that stuff for real, okay?
01:51 You're going to see what it looks like to apply all those computer science concepts, especially how to combine them into a real-world platform, where you're making real apps, okay?
02:00 And quite a few, many dozens of my former students have shipped their apps on the app store and you may well too.
02:07 Okay? So this is really, this is a good course to kind of combine or synthesize all of the things you've learned in a lot of your other computer science classes and touch it up against the real world.
02:19 Okay? The prerequisites for this class are super duper important, okay?
02:24 This, it's just key to make sure you have these prerequisites and really think long and hard, if you don't, whether you want to give this class ago.
02:31 CS 106 A&B or, or CS16x are absolutely required, okay?
02:37 If you don't have that or equivalent, definitely, don't even think about it.
02:40 The second requirement I've added this quarter, based on experience, is CS107 or CS108, which is great, by the way, if you're taking CS108, you'll really be ready for this class.
02:50 Or even CS110, and part of the reason I'm requiring these extra classes is just so you're farther along the programming experience curve because this class is a lot of programming, and so for those of you who are used to a lot of programming, you, you're used to it.
03:06 But for those of you who aren't it's kind of like, whoa, do a lot of programming here.
03:10 It's going to be a little unbalancing.
03:12 So, that's why I've required all those.
03:14 Now if you've done a summer internship of you've done some programming or something like that, that's definitely a substitute for CS107, 108, or 110, right?
03:23 Or if you've done some other CS class that's even more advanced than these, that's fine too.
03:26 You've just got to understand that this class is, you know, a programming class, there's a lot of programming.
03:32 And most importantly, you got to really be comfortable with object-oriented programming.
03:35 So I put a bunch of terms up here, like message and instance variable and superclass and subclass, if you don't know these terms like the back of your hand, it's going to be hard for you to get this class, because I'm going to be throwing those terms out left, right, and center.
03:48 iOS7 is completely object-oriented.
03:51 Okay, the whole structure, the design of the thing, is object-oriented.
03:54 So, you just got to know that, and if you don't know that, you definitely want to go get that first.
03:59 Okay? Take CS106a&b equivalent first, and then get a little more programming experience and then you're good to go.
04:05 Okay? We're going, you're going to be writing apps in this class with dozens of classes that you're going to write by the fifth, sixth week so, you know, if the biggest app you've ever written is got 3, or 4, or 5 classes in it, oh, this is going to be a step up.
04:22 Okay? The assignments, we've got this weekly assignments for the first six or seven weeks, and then you've got a final project at the end.
04:30 All of the homework assignments have detailed write-up of the required task and what we're evaluating you on.
04:35 And they also have hints in there, because I'm not trying to make the homework assignments be really, really hard, and all the homework assignments also directly are re [pause], they're basically reinforcing what has been taught in lecture in that week, they're not a bunch of random new stuff to learn.
04:51 I'm a big believer in a teaching methodology, which is I'm going to tell you about a concept, via slides, and then I'm going to show you it by demoing it to you, actually writing an application that does, then I'm going to ask you to do it on the homework.
05:06 So that's three times you're going to see every single thing pretty much in this class.
05:10 By the end of that, you're going to know how to do it.
05:12 Okay? And you're going to feel confident and experienced to do it.
05:15 So the homework is all about that.
05:17 It's about just doing what you saw me do in class and talk about in class and apply it.
05:22 Alright. Now I'm going to really briefly go over what's in iOS, I think most of you know what's in iOS, hopefully you've all seen an iOS device or you have one in your pocket, I bet 90 percent of you do in this room, but I'm going to try and summarize it, this is really hard to do because I'm going to try and do it in four minutes or less, or five minutes, and it's so big that, I mean, I could have two lectures where I just talk about all the different things and just summarize them.
05:48 So, this is going to try and group them into some sort of sensible groups so you have an idea of what's there from a development standpoint, then when we go off and start doing it all then you'll start realizing whoa, and once you learn how to look in the documentation you'll see, oh, look at all that stuff in there, and you'll figure it out.
06:06 So this is just a high-level overview.
06:07 So, I, I've used this division into these four, kind of groups.
06:13 Core OS, which is the stuff that's close to the hardware.
06:17 Core services, which is an object-oriented on top of that, that kind of makes it so you always are programming an object-oriented layer.
06:24 Media, because these devices are basically iPods with a phone in them or with a big screen on them, but media is really important to these devices, and then finally Cocoa Touch, which is the UI layer.
06:34 Okay? Of buttons and all the switches, things like that.
06:37 So let's talk about what's in each of those layers, kind of, little skimming the surface of what's in those layers.
06:43 At the Core OS layer, near the hardware, is a Unix kernel.
06:48 Okay? This is a Unix operating system on this device.
06:52 And BFD-based mock, and so you get everything you get with Unix.
06:58 You're getting sockets and you're getting file system, permissions, all that stuff, plus you're getting a bunch of other stuff that's kind of specific to a mobile device like this, like power management, and key chain access to kind of manage the security of things.
07:14 Bonjour, which is this kind of network, finding other things on the network.
07:18 So it's got all that stuff, it's a very powerful underlying operating system.
07:23 But all of that API or most of it is in C, and we want to be programming kind of purely object-oriented layer.
07:29 So we're going to be mostly operating when we're talking, touching those things at the Core surfaces layer.
07:35 So this layer has things like language, things that, that kind of make the language more powerful, like arrays and dictionaries, and strings and things like that, plus it has object-oriented ways to access the file system, it has object-oriented ways to find out the GPS location of your device, for example.
07:53 It has ways to do multithreading.
07:57 All this stuff what you want to be able to do, but you want to stay in an object-oriented kind of mindset as you're doing them all.
08:04 There's a huge layer, foundational layer there at Core services for doing that.
08:10 At the media layer, don't sleep on this layer, really important layer, you've got video here, you've got video editing, you got images, of course, that it can display, it's incredibly powerful audio for doing 3D audio, if you have games, you can make the Thai fighters feel like they're ripping by you and stuff.
08:25 All that stuff is in here.
08:27 This is part of, the part of iOS that really I can't cover in a lot of depth.
08:31 I'm just going to try and let you know that it's there and you're going to dive down depending on what kind of applications, later in your life, you want to build.
08:39 But there's an enormous amount there.
08:40 This is a fundamentally, a multimedia device, obviously, and then, Cocoa Touch is where we're going to spend most of our time.
08:48 This is where you are going to be building buttons and sliders and text fields, talking to each other, and animation happening, things sliding in and out, and, you know, fading out and fading in.
09:00 If you want to get the, a picture from the camera from the user, you can do that.
09:04 Things like localization so that you're app can run in many countries in the world and up your sales by doing that.
09:10 A whole map kit for doing all the 3D maps that you've probably seen in iOS7 and all that stuff is all in there.
09:17 And, there's even a view in there that's an entire web browser in a little rectangle that you can just plop right into your app.
09:25 So these are really high-level objects, and we're going to really be diving into this layer, alright?
09:32 So this is really the primary.
09:33 And it's called Cocoa Touch because the API in here was originally developed for Mac OS X, and it was called Cocoa, and of course then when they went to iOS, they adapted, and a lot of API is shared between the two platforms, and, in fact, if you develop an iOS app and then you say someday, oh, I want to develop an app for the Mac using Cocoa, it's going to be very similar.
09:54 Okay? You're going to be really, it's going to look familiar.
09:58 So Cocoa Touch, obviously, is the touchscreen version of that, of Cocoa.
10:03 Okay?
10:04 This technology, Cocoa, has been around a long time, okay?
10:08 Probably almost 30 years, believe it or not.
10:11 From even before Apple acquired it to make Mac OS, what is now Mac OS X, and so it's a very mature API, okay?
10:19 And it's very well thought out, so, especially if you go with the flow of it, it's very easy to build really powerful things.
10:28 So, that's what's in there.
10:30 So let's talk about the tools we use as programmers, as developers, to build these apps, okay?
10:36 And I've divided those into kind of four sections here.
10:38 One is the tools, the actual programming tools, and what's great, on this platform, is itÃs pretty much a one-tool fits all.
10:47 Okay? There's this one tool, XCode 5, and everything's in there.
10:51 You're debugger's in there, all your source code editing, your source code control, the UI building, everything is in this one app.
10:57 There's a little adjunct there, instruments, which is for things like profiling your app and things like that.
11:03 Memory usage, those kind of things, but you're really, all was inside XCode 5, which is really nice because, you know, when you're debugging, you're usually editing your code at the same time, back and forth, back and forth, you're going to different apps and all that would be a pain in the neck, and they've really done a good job of arranging the screen space so that it's sharing between all these different tasks that you need to do.
11:23 So that's the primary tool, XCode 5, you should all, right after this class if you want, go to the Mac App store, not the store on you iOS device, the Mac App Store on your Mac, and download this.
11:34 It's free, available, came out last Friday, and you can download it, install it, and, you know, start playing around with it.
11:41 Some of you might have already used XCode, like in CS106, raise your hand if you've used XCode before for anything.
11:47 Okay, so two-thirds or more, three-quarters of you.
11:50 So, you're going to be used it.
11:51 You're just going to start using XCode now to develop for iOS, alright?
11:55 There's a new language for you to learn, objective C, it's kind of a funny-looking language, okay, its square brackets and colons, no parentheses on message calls, which is kind of weird for people who are coming from Java or C++ or whatever.
12:08 The arguments are not put in parentheses or whatever, and I'm going to show you all about objective C, I don't expect you to know anything about it coming in, and if you know Java and C++, which you should if you've taken CS106A&B, then objective C is not going to be a big leap for you.
12:23 It's a little bit different language, it's a little more fast and loose than Java, for example, and it's a little more, kind of simple and elegant, than C++, when it comes to the object-oriented stuff.
12:32 So, I think you'll like it.
12:34 It won't. Some of you who are very, you know, correct programming kind of thing, you love Java, might find objective C a little wild west for you, but you'll get over it.
12:44 Frameworks, obviously, any big system like this groups all of its objects into libraries, essentially.
12:50 We call them Frameworks in iOS, so there are dozens of frameworks in iOS.
12:56 The two main ones we're going to look at, at the beginning of the course, are foundation, that's where all that core services stuff is, like arrays and dictionaries and all that.
13:04 And then UI kit, okay, that's where buttons and sliders and all those things area, so those are the two main ones, but, there's a whole bunch of other ones, like, you see the Core Data written up there, that's the object-oriented database.
13:14 Okay? So we're going to be doing that.
13:16 Core Motion, that's the gyro and accelerometer.
13:19 Map Kit, obviously the maps.
13:21 And there's dozens more, okay?
13:23 And we'll cover as many of them as we can, obviously we can't do it all in 10 weeks, but we'll do as much as we can.
13:28 And then the last part of developing application in this platform is a design strategy called MVC.
13:34 Now, this is not unique to iOS, other platforms use MVC, Model View Controller, as their fundamental design strategy.
13:42 So how many people in this room have used MVC on any platform?
13:46 Okay, so about half, so you'll know what this is.
13:48 So, I'm actually going to go over MVC for those of you who haven't and I'll go through it pretty quickly, because it looks like most of you, half of you have done it, and [pause] the main thing to see in MVC here, for those of you who already know what it is, is to see how I talk about it so that when we get into iOS and I start saying things like your model is UI independent, you'll know what I'm talking about and we'll all be on the same page.
14:13 So this is mostly kind of getting us all on the same page terminology-wise.
14:18 So MVC, Model View Controller, is essentially a strategy for how to organize all the classes in your application.
14:28 And what we do fundamentally is we divide all the classes into one of three camps.
14:34 The model camp, the controller camp, or the view camp, and what, how you decide what goes in each of these camps, well, the model is essentially the what of your program.
14:45 What is your program?
14:46 So, as we're doing this MVC talk, I'm going to talk about our first application we're going to build which is a card matching game.
14:52 Okay? So we're going to build this game, it's gotta bunch of cards on the screen, like playing cards, you know, Ace of Clubs and all that, and you're going to be able to go choose the cards and you'll get certain points if the match.
15:03 Like the suit matches or the rank matches, or whatever, you get more points, less points whatever, but you're doing that.
15:08 In that kind of application, a little card matching game, the cards and the deck, and even the logic for how the game is played are all UI independent and in the model.
15:20 Okay?
15:21 So how the cards get drawn on screen is the job of the controller.
15:25 So the controller is, it's job to figure out how am I going, you know, take this set of cards and display them on screen, and then animate their movement and things like that.
15:35 Okay? That's up to the controller.
15:36 So the controller controls how the model is presented on screen, and the view, the minions, the classes that the controller is going to use, kind of like the building blocks, the Lincoln Logs, I don't know maybe that's before all your time, but, you know, the things we're going to do build our UI we're going to use in the view, so, the stuff that's in the view is pretty generic.
15:59 Generic UI elements, the stuff in the controller is very specific to how your UI works, and the stuff in the model is completely independent of how you're UI works.
16:08 Okay? So, doing MVC is about knowing where things go, but also about how to communicate between these three camps and so I'm going to try and summarize how the communication works between these camps and I've used road markings, you see the double yellow line and then the dashed white line, so that's like you're driving in your car, try to use them as that I have an image for how this communication happens, where it's allowed, where it's not allowed.
16:35 Okay? So let's talk about the controller talking to the model.
16:39 Okay? Going from that side of the road over to the model side is a dashed white line, in other words, you can head right across there, you probably want to look before you go, but you can go right across, okay?
16:49 The controller has to know everything about the model and it has to have complete ability to talk to the model, use its public API as much as it wants, because the controller's job is to present the model to the user using its view as its minions, so it has to have this access.
17:06 So that's full, unrestricted access the controller has talking to the model.
17:10 This is a one-way era, or one-way arrow, from the controller to the model.
17:15 And similarly from the controller to the view, is also unlimited communication because the controller is responsible for talking, using, it's own minions, the view is the controllers' minions to lay out the user interface and all that stuff, so the controller can do anything it wants, I've put that little green word outlet up there because when we have a property of a controller that points into the view, we call it an outlet.
17:39 Okay? And you're going to see that in the demo on Wednesday, I'm going to say oh, let's create an outlet from our controller to our view so our controller can talk to its view.
17:47 Alright? What about this communication?
17:49 Model to view, never, and why is that?
17:52 100 percent obvious.
17:54 The model is completely UI independent.
17:56 So there's absolutely no way it could talk to a view or object or anyone in that camp.
18:01 Because the view objects are fundamentally UI objects, they're kind of generic, but they're still fundamentally UI objects.
18:06 Similarly, since the view objects are kind of generic, they can't be talking to any specific model.
18:11 They need a controller to interpret a model for them.
18:15 Okay? So there's never any communication this way, that's why it's a double yellow line, that's why these lines are red, that's why there's fire, okay?
18:23 Never go across that line, ever.
18:25 [Pause] What about the view talking back to the controller?
18:30 You got these generic view objects, like buttons, can they talk to the controller?
18:33 Well...yes, they can, but they have to be careful because the view objects are generic, so they can't really know much about the control, so, they can only communicate back to the controller in a blind way, where they don't know the class of the thing they're talking to, and, in a structured way, a way where we all agree, we're going to communicate this way, between the view and the controller, so what's an example of a structured way?
18:58 Well one is called target action.
19:00 So the controller basically drops a target on itself and then it hands out an action, which is like an arrow, to the view and says to the view, okay, when you do what you do, like you're a button and someone touches you or you're a slider and someone moves you, send me that action.
19:18 Okay? So in this way, the generic button, or slider, is communicating back to the controller, it has no idea that it's a card game controller or a space game controller, it doesn't know what kind of controller it is, all it knows is that when something happens in itself, boom, it sends messages to targets.
19:33 So that's a blind, simple, structured way for the view to communicate with the controller, okay?
19:40 But what about more complicated ways?
19:42 Sometimes the view, things are happening in the view that are somewhat complicated and the controller needs to be informed of what's going on, synchronizing what's happening.
19:52 And one way to think about this is these words I put here, will, should, and did, when the view is kind of like [pause], let's say on the scroll view and I'm scrolling around, and I want to let the, the controller, somebody, know that the user just did scroll.
20:08 Okay?
20:09 Or the user puts down the touch and is about to scroll, I want to let the controller know the user will be scrolling.
20:16 Okay? Or the user puts a touch down and the scroll view wants to know, should I allow the user to scroll here, is that allowed?
20:23 All those things, the scroll view itself might not have enough logic to know the answer to those questions, so what it does is it delegates the authority to answer those questions to some other object.
20:36 Now it doesn't know the class of that object, all it knows is that other object can answer these questions, will, should, did, this, that or the other thing, like, should allow scrolling, did scroll to point, things like that.
20:48 So those are the kind of methods you're going to see in these delegate protocols.
20:52 Now I know that CS106A&B do not teach protocols, the word proto, how many people know what the word protocol means in object-oriented programming?
20:59 See, very few of you, so I will be teaching that.
21:02 A protocol is just a blind way to talk to another object.
21:05 You're, you're going, when I teach you, you're going to be like, oh yeah, I know what that is, we didn't really call it protocol, or whatever.
21:10 But, that's how we do delegation, okay, this blind communication.
21:15 Also, another important thing is that views should not own the data that they're displaying.
21:21 They should not own it.
21:22 In other words, it shouldn't be a property inside of them where that's the truth of that data.
21:28 And the easiest example for this is all the songs in your iPhone, on your phone or your iPad, right?
21:34 You might have 10,000 songs in there.
21:36 So if you have some kind of generic list view in your view, you can't transfer all 10,000 songs to its instance variables and expect it to hold 10,000 songs so it can list through it.
21:48 A, that would be inefficient, and B, that information, those 10,000 songs belongs where?
21:53 In the model, okay?
21:55 Because you're song database is a model.
21:58 It has nothing to do with UI's, just a list of songs and artists and albums and all that, it's in the model.
22:03 Some controller has to look at that database and tell a view how to display all those songs, okay?
22:10 So, we need that communication to happen here and the view is displaying some sort of list, and you're touching down and you're flicking on the list and trying to see more songs, how does that communication happen, and the answer is, we have another special kind of delegate, which we call a data source.
22:27 Now the data source doesn't do the will, did, should, it's going to be asking questions like count, like how many songs are there?
22:34 And the controller looks in the model, 10,000.
22:37 Response to the view, there's 10,000.
22:39 The view makes space, internally, for 10,000 things, it doesn't know what they are, moves the scroll bar indicator a little bit, so that you know where it is, and then you start scrolling, flipping through it, and its start sending the message to the controller, give me the data at [pause]
line 150, next 10 items.
22:57 See what I mean?
22:57 And then you flick down some more, now it's saying 250, 10 more items, and so the controller is going back to the model and saying give me more, give me more data, and it's providing it to the view in this blind way.
23:07 So see how the view is getting data from the model through the controller, in this kind of blind structured way.
23:13 Okay? That makes sense to everybody?
23:16 So data source is just a kind of delegate, it's a specific kind of delegate for getting data.
23:20 So you're going to see that there are classes in iOS that have a data source, and they usually also have a delegate.
23:26 Most sophisticated classes in iOS have a delegate, the will, did, should kind of things.
23:31 Some of them have a data source, it depends on whether they're showing a lot of data or not.
23:36 Now simple data, like if I had a view, if I invented a view for my card game called playing card view, and it just has a suit and a rank, okay, we're not going to do count data at for just suit and rank, we are going to set those properties.
23:49 And so the view then would have those, that data set in it, but it wouldn't be owning it, right?
23:54 The model would still be owning the suit and rank, the view is just getting that data to present it.
24:00 Okay? So simple data we might transfer to the view, but it's merely for it to display it.
24:06 Okay. This all adds up to the controller's job being to interpret and format the model data for the view.
24:16 That's the controller's job.
24:17 And when we do our demo, I'm going to be marking like, oh, see, I'm writing this code, this makes the controller perform its job, which is to take the model data and put it in, and using it to view minions, put it on screen, okay?
24:30 That's what the controller does.
24:32 What about this communication?
24:33 Can the model talk to the controller?
24:36 Again, obviously that's verboten because model knows nothing about UI, so it couldn't possibly talk to a UI object like the controller.
24:44 But sometimes things change in the model and the controller needs to know about it.
24:47 Okay, data changes, a database changes or the model is some network database and somebody changes something on the network and it changes, and the controller needs to find out.
24:56 So, how do we do that communication?
24:59 We do that using kind of a radio station model.
25:03 Okay? So the model, a radio station concept, the model will use this concept to essentially broadcast information to anyone who's interested, okay?
25:14 And the mechanisms for doing this in iOS are called notification and key value observing, KVO we call it, and so the model can just say, oh, anytime something changes in my model, I'm just going to broadcast on my radio station and then the controller simply tunes into that radio station.
25:32 And it can find out things are changing.
25:33 And when it finds out something changes, it's going to communicate via its green arrow to the model, and say, okay, give me that data that changed.
25:42 Alright? Does that make sense?
25:44 So towards the end of the quarter, we'll start seeing a little how to do notification to find out, for example, if the data in the database changes.
25:50 We'll get a notification, the UI can then, you know, the controller can then go talk to the model to get the info.
25:58 Okay? [Pause] Some people have asked, can a view tune into the radio station?
26:01 They probably could, but you probably wouldn't want to do that.
26:04 That would probably be a violation of MVC.
26:07 Alright, so, we do this, we have all this nice communication and all these rules, and we can imagine building something simple using this, but what if we want to build a big, complicated app?
26:19 An app that has multiple screens on our iPhone or on an iPad it's got, you know, three or four different areas on screen where things are happening, how do we do that?
26:28 Well, we're essentially going to combine multiple MVC's, okay?
26:33 Because you, an MVC can use, as part of its view, another MVC.
26:40 Okay? So, an MVC, an entire MVC, can be one of the minions of some bigger MVC.
26:48 Okay? And by doing that and cascading it down, we can build more and more complicated applications.
26:55 So, an example of this is you might have your calendar app, and it's showing you the entire year, and you click on a month, and now it shows you a month view.
27:06 Well a month view looks a lot different than a year view.
27:08 Month view just has all the days and maybe some circle that tells you where you have an appointment on a day, and then when you click on a day, and now you get a day view.
27:16 Okay? And the day is showing you the hours and what all your appointments are, and you click on an appointment, and now you get an appointment view and it's showing the detail of where you're going and when it is etc. Okay?
27:25 Well each of those views, the year view, the month view, the day view, and the appointment view are their own MVC's.
27:33 Okay? But you can see how the last three, okay, are used as, essentially, a minion of the top-level view, the year view, to show more detail.
27:44 Okay? So the year view, you click on a month, it's going to use the month view MVC to show more detail, so it's part of its view, okay?
27:53 So, you see this also in iOS with tab bar controllers, right?
27:57 You have the tab bar, along the bottom, I have four or five things you can choose, well there's some MVC at the top who has four pointers to four minions, which are the four MVC's that are each going to appear in a tab bar, okay?
28:11 We'll be doing that, for example, in assignment number two or three, where we'll be making a tab bar and you're going to have to do multiple MVC's.
28:18 Okay? So, that basically results in a picture that looks kind of like this.
28:23 Alright? Where you got this MVC and you see the purple one that's like underneath the word together there, and it points to three other MVC's outside of its view thing, okay?
28:34 That's how we're going to build this, that might be a tab bar controller and those might be the three tabs.
28:39 Okay, and each one is its own little MVC, completely independent, operates on its own, doesn't even know it's a generic, reusable view like thing at this point, it doesn't even know that it's in a tab bar.
28:50 Okay? It just knows that it's supposed to do whatever it does.
28:53 And so it's modular in that way.
28:54 You can also see that there's no communication between any other, there's no other arrows, except for some of the models.
29:00 You see some of the models are communicating with each other, you know, a big application might have single, shared model.
29:07 Or, you know, the models might be split off into pieces to be used by sub MVC's, okay?
29:12 But that's the only kind of communication you're going to have there, all other communication is either the structured communication we saw in the MVC or it's using MVC's as part of the view of another MVC.
29:24 Any question about that?
29:27 So we definitely don't want to be having designs that look like this, okay?
29:32 Where everybody's talking to everybody, we can't tell who's talking to what, it's just impossible to debug a program like this and it doesn't scale.
29:38 You can't build really big programs this way, it just becomes impossible to know how touching anything would break everything, right?
29:44 So we're definitely not going to be doing that.
29:48 Okay? Okay, so that's MVC.
29:51 No questions about that?
29:53 Alright. Onto objective-C.
29:55 So, objective C is a strict superset of C, so everything you can do and see, you can do in objective-C.
30:02 Okay? And we'll do a lot of C things in this class.
30:05 We'll do a lot of object-oriented stuff too, but we're going to do a lot of C things, as well.
30:10 But, there's obviously a few things that you want to think differently about because you have object-oriented stuff added onto a language, and we're going to talk about one of them today, in addition to showing you a little bit of the syntax, we're going to talk about one of these different, think differently things about objective-C that's different than C++ or Java, which is properties.
30:33 Okay? And I'm not going to read through all of this, I'm just going to show it to you, but properties are basically how we access our instance variable, right?
30:40 Everybody knows what I mean by, raise your hand if you know what I mean by instance variable?
30:45 Okay good.
30:45 So pretty much everybody.
30:46 So, we want to access the instance data of our objects.
30:52 And, normally, in Java or in C++, you just, you know, have some syntax to access them and you just access them.
31:00 In objective-C we don't do that.
31:02 In objective-C, we have what's called a property, and a property is basically a setter get method and a getter method.
31:09 And that's how all access to the instance variable goes, through a setter method to set the value and a getter method to get it.
31:15 And some people who maybe are kind of [pause] performance junkies might say, oh my gosh, every instance variable I have to call a method to set it or get it?
31:24 But, remember, you're building for a user interface system here, when the user touches down, that's taking million, a million code, you know, you're executing a million instructions there in that amount of time.
31:38 So, having a few extra setters and getters is completely irrelevant, right?
31:41 So it's the old [inaudible]
thing, right?
31:44 You don't want to optimize things that don't need to be optimized, okay?
31:47 You want to optimize the things that are taking a lot of time and accessing instance variable turns out not to be taking a lot of your time, so, let's look at what it looks like, don't get freaked out here by seeing this syntax.
31:59 It's all new, so, it's going to take some getting used to.
32:02 In objective-C, every class we have and the class I'm going to show you today is a, is in our, essentially our model that we're going to build for our card game matching app.
32:13 We're going to have a card and a deck, and we're also going to have a subclass of card called playing card and a subclass of deck called playing card deck.
32:20 Those are the four classes that are going to be in our model, to start.
32:23 And, so, I'm going to show you, in today's lecture I'm just going to show you card, only card, and then on Wednesday I'll show you deck and playing card deck and playing card.
32:33 So, every class in objective-C, you have a header file, card.h, and you have an implementation file, card.m. Okay, this is just like in C++ you might have that h and dot c, or whatever, this is dot m, m I guess is for implementation, I don't know.
32:49 But it's m [laughter], and so you have these separate things, the difference here is card.h is the public API.
32:58 That's what your dot h is.
32:59 It's your public API.
33:03 Card.m is your private API and all your implementation, okay?
33:09 Don't get confused about dot h and dot m. All dot h is your public API, that's all it is.
33:14 It's what methods in your class you want to make public so that other people can call them, okay?
33:21 So, let's see what the syntax looks like.
33:24 In your public API, you must say who your superclass is.
33:28 Okay? You are not allowed to make your superclass be a secret, okay?
33:33 It has to be public so we have to put it in the header file, and you can see the syntax we use is at sign interface, the name of our class, which should always match the name of the file, by the way, card.h should always have the interface for the class card.
33:47 And then a colon and then your superclass.
33:49 Now the superclass of the card class is NSObject.
33:52 NSObject is in the foundation framework and it's pretty much the root class of every single class in all of iOS, including all the classes you write.
34:03 Okay? It's this kind of basic class, we'll talk about it when we talk about foundation, but it's going to be the superclass eventually of every single class.
34:10 Right? Everything, eventually, inherits from NSObject.
34:13 Now, on the implementation side, it looks very similar, but instead of saying at sign interface, you say at sign implementation and the name of the class.
34:22 And here you don't specify your superclass, okay?
34:25 Because you're only allowed to specify that once, and its public, so it goes in your header file.
34:30 Notice that the bottom of both of these, little at sign end, do you see that?
34:34 Okay, that just means that's the end of the interface or of the implantation.
34:38 Okay? So all of your public API goes inside this at sign interface block, at sign interface, and all of your implementation, your private implementation goes in the at sign implementation part.
34:49 Now, if you import, if you have specified your superclass here, you have to import it.
34:56 Okay? Which is like pound sign, include.
34:57 It's a little more powerful than pound sign, include, in fact, it's a lot more powerful, as I'll talk about in a second here.
35:03 >> But you must import it, otherwise the objective-C compiler won't know what that superclass is, so you have to, obviously, import your superclass.
35:10 However, we don't usually, when our superclass is something that's in iOS, we don't usually import just that classes header file, which in this case is foundation, we actually import the entire framework.
35:23 Okay? Now you might say, oh, that's inefficient.
35:26 [Pause] A huge framework, but of course this is all precompiled and optimized.
35:32 And, in fact, in iOS7, the syntax for this is really to say at sign import foundation.
35:39 That means I'm going to use all the public classes in the foundation framework.
35:44 iOS7 still supports the old important foundation slash foundation.h so you can use that if you want.
35:51 Now on our implementation file, we have to import our header file, obviously.
35:57 Okay? Because our implementation file needs to know what we're committing to publicly, in terms of our API, so we have to import that.
36:05 Makes perfect sense.
36:07 We can also have private declarations, okay?
36:11 Declarations of properties and methods that are private inside of our implementation file by putting this little at sign interface, name of our class, open parentheses, closed parentheses.
36:23 Okay? And then at sign end.
36:24 So we can have a little space here where we can little private declarations.
36:27 Now, objective-C does not require you to declare something before you use it in a file, you know what I mean by that?
36:34 And there's a lot, a lot of languages, you have to declare a method before you can call it, right?
36:40 But you can do it out of order in objective-C, you can implement a method here that calls, you can implement method A, calls method B, and then method B is implemented down here later in the file.
36:50 Okay? So you don't have to declare method B first, then implement method A, and then implement method B. So, this little private at sign interface we're mostly going to use for properties.
37:01 Okay? Because when we declare a property, as you'll see, that setter and getter get written for us.
37:06 So let's see what that looks like to declare a property.
37:10 So here's a simple property.
37:12 It's called contents.
37:13 So this is the content of the card.
37:15 This is what's on the card.
37:17 So this might be ace of clubs.
37:19 Okay? And because this is your first day, we're going to make the contents be very simple, just a string.
37:26 Okay? So these cards, they can be like a flashcard, maybe, for learning a foreign language, maybe this is the, the contents are the word that you're trying to learn and maybe it's a flashcard of images where this content is the name of some image and it's up to UI to display an image that matches it.
37:43 Or in the case of our playing cards, we're going to have this be like, literally the character A and then the character clubs, because there's Unicode character clubs, so the A clubs, that would be the content.
37:53 So this is the content of the card, what's on the card.
37:56 And you can see that it's an NSString star.
38:00 You see at sign property is how we're going to declare that we need storage, per instance of card, in other words every card has its own contents, and it's going to be a string, and so we say property NSString star, now, it's important to understand that in objective-C all objects, all of them, live in the heap and we have pointers to them.
38:23 Okay? There's no such thing as making an object on the stack or anything like that, okay?
38:29 They're all in the heap.
38:30 Everyone knows what the heap is?
38:31 Any questions about that?
38:32 That's just where you allocate free memory.
38:34 So all objects are there.
38:36 What's' really cool about objective-C is, objective-C will manage all that storage for you.
38:42 It will allocate for you and free it for you.
38:45 Okay? Now how does it know when to free it?
38:49 And the answer is this strong thing, you see the word strong there?
38:54 If, your properties can either be strong, like this one, or weak, two things, strong or weak.
39:00 Okay? And all pointer properties have to be strong or weak because the objective-C has to know what to do with the memory and the heap.
39:05 Strong means keep the memory for this, for the thing this points to, in the heap, as long as I or anyone else has a strong pointer to it.
39:18 Okay? So, this is called reference counting, it's not garbage collection, its reference counting.
39:22 So we're going to, the objective-C is going to keep track of every single strong pointer to an object in the heap and as long as at least one strong pointer exists, it's going to keep that thing in heap.
39:33 As soon as there are no strong pointers left, it will free the memory out of the heap, instantly.
39:37 Not garbage collected later.
39:39 But actually instantly, reclaim that memory.
39:42 Okay? So this is probably new to you, you're probably used to like garbage collection in Java, for example, or explicit memory management in other languages.
39:52 This is called automatic reference counting and it's awesome.
39:55 It's really very predictable, this is much better than garbage collection, because, you know, the garbage collector can come along later and do, wreak havoc on the performance of your application as it goes and collects things from the heap.
40:06 This is very predictable, you know exactly when things are going to be released, it's when there's no strong pointers left to it.
40:11 What would it mean if this was weak?
40:12 Okay, if you have a weak pointer, that tells objective-C, okay, I have a pointer to this thing in the heap and keep it in memory as long as someone else has a strong pointer to it.
40:22 But as soon as no one else has a strong pointer to that thing, it gets freed from memory and this pointer, if it was weak, gets set to nil.
40:30 Nil means this pointer doesn't point to anything, okay?
40:33 Nil is the same as zero.
40:36 Okay? In other languages, you're probably afraid of nil pointers.
40:40 Okay? Because you do reference a nil pointer, it crashes your program, right?
40:45 In objective-C, you can send messages to nil pointers even and it will not crash your program.
40:50 In fact, if you send a message to a nil program, to a nil pointer, it will not execute any code, obviously, because there's no instance there.
41:00 And it will return zero from, if that message had a return value, it'll return zero.
41:05 So you have to be a little careful of messages that return structs, okay, but as long as it returns a primitive type or a pointer, it'll just return zero.
41:13 So, this is going to take getting used to.
41:16 The fact that we are going to program knowing that we can send messages to nil, to pointers that are nil and that that's good.
41:23 We'll actually make our code work nicely and we'll use that to our advantage.
41:27 And that is definitely going to be a change for you who are used to if pointers not nil, then send message all the time, right?
41:34 Protecting against crashes, you don't do that in objective-C, you just don't code it that way.
41:39 Okay? So, this pointer could have the value nil, n-i-l, which means it doesn't point to anything.
41:46 Alright? So if you have a strong pointer and it points to something and then you set it to nil, now that strong pointer doesn't point to that thing, as long as no one else points to it, you can clean up that memory, objective-C will clean the memory up for you.
41:57 Or if you have a pointer that points to something in the heap, then you make it point to something else in the heap, then you no longer have a strong pointer to that other thing in the heap and as long as no one does, it'll get cleaned up.
42:07 Okay? And remember weak not only cleans it up, but it sets your pointer to nil, because you only wanted a weak pointer, you only wanted it to point to that thing as long as someone else does.
42:16 Okay? So that's the strong versus weak.
42:19 The other thing we're going to put in this little parentheses is nonatomic, okay?
42:24 Nonatomic means calling this setter and getter that go along with this property is not thread safe.
42:31 Okay, so you can't have two threads trying to set this property at the same time.
42:36 Why do we say nonatomic here, why do we want this to not be thread safe?
42:39 Because the way we do multithreading in iOS is not by having a single object that multiple threads are setting on, we usually have a separate set of objects that are running in another thread, like your model, and then other, than your UI stuff is running in the UI thread and they're talking thread to thread.
42:56 Okay? So we don't need this and not only that, what's going to happen here when we do this at sign property is objective-C is going to create that getter and setter methods that I told you about to set these contents automatically for us, and we want them to be simple, okay?
43:12 This is what they're going to look like.
43:14 We want them to be simple.
43:16 If we don't say nonatomic, there's going to be all kinds of locking code in there, right?
43:20 If you have multiple threads and you're allowing multiple threads to access the setter and getter here, then you need locking code, and we don't want locking code, especially if we're going to implement the setter and getter ourselves, which we're going to, sometimes.
43:34 Okay? But the default here is that we don't implement this setter and getter, it's automatically in there forest.
43:40 So you can see there's three parts to this.
43:42 There's the at sign synthesize, you see that?
43:44 That's basically just saying underbar contents is the name of the instance variable in which the property contents is going to be stored.
43:53 Now we could say at sign synthesize contents equals foo [phonetic], and then contents property would be stored in an instance variable called foo.
44:00 But that would be very confusing, so we always use underbar name of the property.
44:05 Okay? And so that's part one, just basically allocating an instance variable to store this contents property.
44:12 Then there's the getter, that's NSString contents, return contents, so the dash, parentheses, NSString contents is a method declaration in objective-C, the dash means this is a method, parentheses NSString star means this is a method that returns a pointer to a string, and contents is the name of the method.
44:33 Okay? So the name of the method of the getter is the same as the name of the property.
44:37 Then, the implementation is just return that instance variable that we synthesized.
44:43 Okay? And similarly, the next method is a method in objective-C for setting it.
44:49 And, again, dash [inaudible] method.
44:51 Parentheses void means this method does not return anything.
44:55 Okay? That's what parentheses void means.
44:57 Then set contents colon, that's the name of this method, set contents colon.
45:03 Parentheses NSString star is the argument to this method.
45:07 Contents is just the name of the argument, the local name of the variable in the local contents, context, and the implementation is just underbar contents, our instance variable equals that argument.
45:20 Okay? So, before I move on, does everyone understand how these two methods are allowing you to set and get an NSString storage space inside your card?
45:33 Everyone understand that?
45:35 Question? [Inaudible background question] Okay, so the synthesize line, again, is just specifying the name of the instance variable that we're going to use to store this stuff in, underbar contents.
45:47 It's kind of weird, you could maybe, it might be better saying at sign synthesize contents to use instance variable with name, underbar contents.
45:56 That equals, I know, is a little weird.
45:58 It sounds like it's assigning something, but it's just, that's what, think about equals as, you know, we'll use the instance variable with the name, underbar contents.
46:06 So that's what the synthesize is doing.
46:08 If you don't put the synthesize, it's not going to create the space in your card instance, and it won't, there won't be any name for it so you can't refer to it in your getter and setter, okay?
46:17 Everyone understand this?
46:19 Any other questions?
46:21 Okay, now, the thing about it is, when you type the at sign property on the left, this gets added to your at sign implementation; however, you will not see it there.
46:31 [Pause] Okay?
46:32 So it's there, but you don't see it.
46:34 Okay, objective-C is, made it for you, but it doesn't show it to you, but it's there, okay, that setter method and that setter-getter method are there.
46:44 Okay? They exist.
46:45 And not only that, they're public, because you put that at sign property declaration in your header file.
46:51 Everyone got that?
46:53 So let's look at another couple properties just to see the syntax a little more.
46:56 So here's two properties that are bullions [phonetic].
46:59 Okay? There's no bullion primitive in C, so objective-C has to find, typedef all caps BULL, probably a short or something or an int or a char, I don't know what, but you can think of it as a primitive type, it's a boolean, it's value can either be yes, which is some non-zero value, or no which is zero.
47:18 And these properties don't need the strong or weak.
47:21 Do you understand why that is?
47:24 Because they're primitive types, they're not stored in the heap, okay?
47:27 They're just a int or a float, so there's no memory to manage so you don't need to know about strong and weak pointers, there's no pointers involved here, this is just a BULL, a bullion.
47:35 So there's no strong or weak, but we still have the nonatomic, because we still want the setter and the getter to be simple, not having any locking code or any of that business.
47:42 So we're always going to have nonatomic on every property in this class.
47:46 We will not have a single property in this entire class that is not nonatomic.
47:49 So just put it in there, I wish it were the default.
47:51 Okay? So that's what we're going to do.
47:54 You can see we've synthesized them both and we've got the setter and the getter for them both, and this is all being done for us by objective-C.
48:02 Now, one thing that's kind of cool is we may not like the name of this getter, because we want our code to read something like if card is chosen, then do something.
48:12 If card is matched, then do something.
48:14 So we really want the getter called is chosen, not just chosen.
48:18 You know, if card chosen, not as nice as if card is chosen.
48:22 So it's actually possible to rename the getter by saying getter equals the new name you want.
48:29 Okay? And that's essentially renamed it, same thing, we'll do the same thing with this one.
48:32 Getter equals is matched, now that getter is called is matched.
48:36 And I bring this up because you're going to see how iOS does this with bullion properties, it tends to rename them to is this or has this, depending on what the verb there is.
48:46 Okay? And again, objective-C is writing all this code on, in the implementation, but you don't see it.
48:53 But it's there.
48:55 Okay? Now, [pause]
we're going to talk 48:58 about why properties are good and why it's better than just accessing instance variables directly, [pause] in later lectures, but the bottom-line is it's good for doing things like balance checking, it's good for doing things like when you set a property and you want to updated the UI.
49:13 It's doing good for things for initializing pointers.
49:16 Like that end string star contents property is going to start off nil.
49:21 All properties, in objective-C, all of them, start off zero.
49:25 So for pointer, that's nil.
49:27 Okay? So that contents property, when we create a new card, it's going to not point to any contents.
49:33 That cards going to be blank, okay, it's not going to have anything on it.
49:35 So, it's nice to use the setter and getter, we implement our own setter and getter that will check to see if it's nil, and if it's not, and sometimes, not with contents, but with some properties, if it's nil, we'll create something in memory.
49:49 Okay? So that's another reason you use it.
49:50 So you'll see all these reasons why we want properties in the next lecture basically.
49:55 Alright, so now, let's look at a method.
49:59 Okay? Just a regular, old method.
50:01 You've seen some methods, the setter and getter methods, but what if we wanted to find our own method, our own public method, so I'm going to define this method called match.
50:09 Remember that I'm building a model here for a card matching game, where I'm going to put all these cards on the screen and the user is going to try and match them.
50:16 Pick ones that match, alright?
50:18 So I need a match method.
50:19 A method that tells me whether two cards match.
50:23 Okay? So, I'm trying to make this simple, so I've made a simple match method that has the following semantics.
50:29 It takes another card as the argument, and it returns it an integer.
50:33 That integer is zero if the cards don't match, otherwise, it's an integer that is higher, the better a match it is.
50:42 Okay? So like a really good match might be a thousand, but a not so good match might only be a hundred, and, or, or it could be one.
50:49 Now, the semantics of what that number is, totally depends on the cards, because we're only going to match cards against other cards, alright?
50:56 And we're going to find out how good a match they are by how that, whatever that card class is, and we're going to make a subclass of this class, called playing card, that's going to give more points for matching the rank, okay, than it is for matching the suit.
51:11 Okay? But that's up to subclasses of cards to determine what the point system is, okay?
51:16 So, for our implementation of match, okay, we're going to do a really simple implementation, so, first let's assume that they don't match.
51:25 Okay, so I just made this local variable int score equals zero, you can see that you can assign a variable, actually all local variables also start out zero, so I don't even really need that equals zero, but I'm a big believer in putting that in if that's really, you know, what you intend, and in this case I intend the score to be actually zero.
51:42 The score of this match until I go and see if these cards match, right?
51:46 So it's just a kind of programming style thing here.
51:48 So, how I'm going to tell, how am I going to tell if this card that's been passed in match, matches the card that it's being sent to?
51:56 And the answer is I'm going to send some messages, okay?
52:02 You see the open square brackets notation there, that's the first time you're seeing me send a message in objective-C, and I'm also sending two other messages in this one line.
52:13 Card.contents and self.contents, you see both of those, those are message sends, as well.
52:20 So there's two different syntaxes here for sending a message.
52:23 One is open square brackets, okay, and we'll talk about that one in a second.
52:27 And another one is dot notation, card.contents.
52:31 When do we use them?
52:32 We only use the dot notation for properties.
52:37 That's how we call the setter and getter of properties, using dot notation.
52:41 Okay? Now, here we're calling the getter, card.contents is calling the getter of the contents property on the card instance.
52:52 Okay? How do we call the setter?
52:54 Exactly the same.
52:55 Card.contents, but we put it on the left-hand side of the equals.
52:59 Card.contents equals, now we're calling the setter for contents.
53:04 You see? So here we're calling the getter.
53:05 We're also calling the getter for contents on self, on our self.
53:09 So, in other language this might be called this, right, but you know what self is, right, self is this instance that this code is operating on.
53:17 So, we are going to compare these two strings, card.contents and self.contents to see if they are equal and we are going to do that with the NSString method is equal to string colon.
53:30 So [inaudible] equal to string colon can only be sent to a string [pause], so is equal to string can only be sent to a string and card.contents is a getter method that returns a NSString, so we're good to go, right?
53:43 We're sending is equal string to a string, and the NS equal to string takes as an argument, an NSString and, again, self.contents is a getter method that returns NSString; therefore, we have satisfied all the requirements of this equal to string and we put square brackets around it, and it's going to return a bullion is equal to string is defined to return a bullion whether the contents of those two strings are the same.
54:07 Notice we did not say equals equals.
54:10 Okay, we did not say card.contents equals equals self.contents.
54:14 Because we'd just be impairing the pointers then, not what the pointers point to, okay?
54:20 Everyone understand why we didn't use equals equals to see if those two strings are the same?
54:23 So if those strings are the same, I'm going to give one point, okay?
54:27 So this is either the dirt simple implementation of match, which is if the cards are exactly the same, their contents are exactly the same, I'll get one point, otherwise I get zero.
54:37 Okay? Now we're going to do much better implementation in match when we do playing card, but this is our kind of dirt simple one.
54:44 Now, to give you just a little more about objective-C, what if we changed this method, oh, so, yeah, here's a little bit about who's the sender and who's the receiver here.
54:55 You can look at this in the slides later.
54:57 Okay? But I'm going to make this a little more complicated.
55:00 I'm going to make the argument to match be an array of cards.
55:04 Okay? So now I'm matching this card that I'm sending this to, to a whole bunch of other cards.
55:09 So now I'm going to need some new algorithm to match, right?
55:14 So, again, a playing card match, if let's say you had matching three cards, you might give a lot of points if all three cards are the same rank, they're all jacks, you get a lot of points.
55:23 If only two of them are jacks and the other one is something else, well you don't get very many points at all.
55:28 If they're all through the same suit, you kind of get a medium amount of points, you see what I mean?
55:32 So, here I'm changing match to take an array as the argument instead of just a single card.
55:37 And how would I change my implementation to deal with that?
55:41 Well, I'm just going to put a four-loop around my if and iterate through all the cards and so this implementation, hopefully those of you who are quick thinkers, you can know what this does, this gives you one point if the card that's receiving this matches any of the cards in the array.
55:58 Any, not all, any.
56:01 Okay? Now you can imagine a lot better algorithms here.
56:03 Maybe you get one point for every card you match in the array or you get two points for one match and four points for two and eight points for three, you know, some sort of binary thing, exponential point, whatever, this is first day of lecture, we're just going to give one point if it matches any, okay?
56:18 But mostly what I wanted to show you here is what it looks like to have an array as the argument instead of a single card.
56:25 So that you understand that the argument, what the argument to the method is and also so I can show you the four-loop there.
56:31 You see that four n [phonetic], a lot of languages have that these days.
56:35 That just basically means it's a four-loop where it's going to go through every object in that NS array and assign it to card, card is the iteration variable, and execute that if once for each of the cards in the array.
56:47 Everyone understand that?
56:50 If you have a question about that, ask?
56:56 No? Yeah? [Inaudible background comment] Oh, okay.
56:59 That's a great question.
57:00 So the question is if I just have that four-line, but I said four card card, not four card star card, in other cards, okay?
57:09 We'd get a syntax error.
57:11 Why? Because all objects are always pointed to so we always have that star.
57:16 Okay? Always.
57:17 Alright? You can't have a card not being a pointer to it, so the, you know, objective-C would give you a syntax error there, it's impossible to not have that star.
57:27 Whenever you have the name of the class, it's always going to have that star.
57:34 Question? [Inaudible background comment] Yes.
57:36 The question is, another great one, can I use the square brackets to call the setter and getter instead of using that dot notation?
57:42 And that's a really insightful question and the answer is absolutely you can, it's perfectly legal, because that setter and getter are completely normal methods.
57:50 There's nothing special about them whatsoever.
57:52 Okay? That dot notation is a nicety, syntactic sugar only.
57:57 The question is should you use square brackets for setter and getter, and I think it's a matter of style.
58:02 You would definitely would want to be 100 percent consistent, you would never want to mix them.
58:06 And I think most people, most people would say use the dot notation.
58:10 It makes it clearer, it's a little simpler, nicer, but, you know, you could.
58:15 In this class, please use the dot notation just so I know you know how to use dot notation.
58:19 Question? [Inaudible background comment] Okay, awesome question again.
58:26 Gosh, you guys are so good.
58:28 Can I use dot notation for a method that takes no arguments, but is not a getter or a setter?
58:34 And the answer is objective-C will warn you about that, not give you an error, but warn you, and you should never do that in this class.
58:41 Okay? That is really not that good form, whereas his question was kind of like you can argue, that one, don't do it.
58:47 Okay? So. Use dot notations only for setters and getters.
58:52 Other questions?
58:53 Yeah?
58:54 >> How do you use a setter with dot notations?
58:59 >> So, yeah, question is how do you use a setter with dot notation?
59:02 And it's exactly the same as a getter, it's just that you're using it on the left-hand side of an equals.
59:07 So card.contents equals, you know, A of clubs, that would call the setter of contents, whereas, you know, this is calling the getter, because it's not on the left-hand side of the equal.
59:20 Okay? Excellent!
59:22 That's all I had today, so on Wednesday, we will do deck and playing card and playing card and I'm going to dive right into a big old demo of XCode 5 and show you how all this stuff is actually done, and then next week we'll do, yet more objective-C.
59:38 Thank you very much!
59:40 >> For more, please visit us at stanford.edu.
			</span></pre>
		</div>
	</div>

	<!-- Lecture 2 -->
	<div class="row">
		<div class="col-md-10"><h3>Lecture 2. Xcode 5</h3></div>
		<div class="col-md-2">
	        <ul class="nav nav-pills">
	          <li><a href="Lecture 2 Slides.pdf">Slides</a></li>
	          <li><a href="http://a146.phobos.apple.com/us/r30/CobaltPublic/v4/c2/03/83/c20383e1-73b3-ece1-7429-b14b38ad4384/318-1013471239741048298-02_9_25_13_Wed_720p1500cc.mp4">Lecture</a></li>
	        </ul>
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
		</div>
	</div>
	<div class="row">
		<div class="col-md-12">
			<pre><span class="small">00:05 >> Stanford University.
00:11 >> Paul Hegarty: Okay.
00:11 Well, welcome to lecture number two of CS 193P for fall of 2013/2014 academic year.
00:20 And today we're going to have some slides at the beginning, little more talking, and then I'm going to have quite a big demo that's going to try and hopefully synthesize all the things I've been talking about on the slides for the first two lectures, which is that we're going to start building our card game.
00:36 Okay. This card matching game is going to be our substrate for the first two weeks of learning some Objective-C, learning about Xcode, learning about how iOS hooks up the controller, and the view, and the model to make a UI.
00:52 So if you remember from last time, we did this card thing that -- we did the entire card.
00:58 It was a very simple class.
01:00 Got a couple of properties -- three properties there -- and one method.
01:04 And that's pretty much it.
01:05 And so today we're going to go on and do another class, which is a deck, okay?
01:09 The deck of cards.
01:11 And remember, that card and deck are generic; they're not specific to playing cards, right?
01:17 A playing card, like the ace of clubs or the king of hearts -- something that has all that in it -- that's a playing card thing.
01:22 These are general cards and decks.
01:24 So this could be a deck of flash cards, a deck of foreign language words you're trying to learn or whatever.
01:30 So we're trying to keep these deck and card classes somewhat generic.
01:33 So here's deck.
01:34 It should look familiar in terms of its basic structure, right?
01:37 We're importing our superclasses framework there, and then obviously importing our own header file in our implementation.
01:45 And the interface for deck is going to have these two kind of fundamental methods: One adds a card to the deck and one draws a random card out of the deck.
01:55 Okay? And the add a card to the deck is a little bit new to you because you can see it has two arguments.
02:03 Okay? This is the first method you've seen that has two arguments.
02:05 So far you've only seen methods with no arguments or a method with one argument like that -- match -- match had one argument or the setters, they also have one argument.
02:13 So notice that when you have multiple arguments and objectives, see they're kind of interspersed with the names of the methods.
02:22 Okay? So the name of this method, this long method is add card colon at top colon.
02:28 That's the name of this method.
02:29 Okay? So the at top part is actually part of the name of this method.
02:33 And the arguments, like the card that you're going to add and at top -- which is a Boolean whether to add it at the top of the deck or at the bottom of the deck -- okay, those arguments are interspersed.
02:43 And we'll see how you call such a method in a moment here.
02:47 And then draw a random card is like a, you know, similar to a getter in that it returns a value and it has no arguments.
02:55 But this is not a getter because we didn't make this a property.
02:58 And it's kind of important to understand you could have made this a property like a read-only property or something that reads it, but since draw a random card kind of does something, it has kind of an algorithm to it -- a mechanism -- you usually wouldn't make that a property.
03:13 It's kind of an abuse of a getter to do that.
03:16 A getter is really just setting and getting a value.
03:18 It might have side effects, like setting it might update the UI or getting it might make sure it's initialized first -- those kind of things.
03:26 You're not going to -- something that does something like drawing a card is not going to be a property.
03:31 Now, if you want to have, like, that at top argument be optional, okay, the only way to do that in Objective-C -- obviously we need our header file there -- the only way to do that in Objective-C is to declare a new method, add card colon with no at top on it.
03:48 So this is a totally different method, totally unrelated to the other method except for that in its implementation of this other method we're just going to call the other one, okay?
03:57 So in add card we're going to say self add card at top colon, whatever we want the default to be, which I'm going to say is no.
04:03 Okay? So just understand that, you know, in some languages, like, some arguments can be optional or you can kind of overload things to have the same method name have different arguments.
04:16 No. In Objective-C every method is completely distinct and has a distinct name.
04:21 And extra arguments are interspersed like that.
04:23 Okay? So these would be two different methods.
04:26 That make sense?
04:27 All right.
04:27 So let's talk about our implementation of our deck.
04:31 So our deck is just going to contain a bunch of cards.
04:34 We need some sort of internal data structure to store all our cards in.
04:38 And what we're going do is we're going to get a mutable array.
04:43 So you've already seen the class NS array, which is the foundation class array, which is an array of objects.
04:49 Those objects, by the way, in array can be of any class.
04:51 There's really no way to specify what kind of class of object is in an array.
04:56 Some languages allow you to do that.
04:58 You can specify "This is an array of strings" and it knows that.
05:02 But in Objective-C you can't do that.
05:04 And we're going to talk about how we deal with that.
05:06 That's a little bit of the wild west of Objective-C, but there are ways to kind of check and see what the objects are if you want to be really safe about it.
05:14 But in this case we just have this mutable array.
05:16 And mutable means that we can add objects to the array.
05:18 Normally an NS array is immutable.
05:21 Okay? Once it's created, whatever objects enter it, that's the objects that are in it forever -- you can't take any out and you can't put any in.
05:27 So if we want array where we can add stuff, we have to use this subclass of NS array called NS mutable array.
05:33 Okay? You can see that it's a property.
05:35 It's strong because we want this array to stay in the heap as long as we're pointing at it.
05:40 And of course, we always put nonatomic there.
05:42 Okay? So this is going to be an array of cards.
05:45 Now that we have this, we could easily implement add card, for example, by just saying, "If at top, then insert object," the card, which is the argument to this method -- first argument -- "add index zero." So insert object add index is a method in NS mutable array, not in NS array -- only in NS mutable array because that would be mutating it -- that inserts the object at that index in the array and index zero is going to be the top that we're going to define.
06:15 And then otherwise if we're not going to put it at the top, we're going to put it at the bottom, we're going to use a different NS mutable array method called add object.
06:21 And that just adds something at the end of the array.
06:23 So everyone cool with that?
06:25 So I mostly just put this method in here just to show you there's a couple of different methods on mutable array and, you know, how we can use the arguments.
06:32 It's no big thing here; it's just kind of to get more used to what's going on here.
06:38 All right.
06:38 So that's add card.
06:39 Very, very simple.
06:40 And there's a problem, though.
06:43 In this add cards, if we just created a deck and then called add card, it would not work.
06:52 Okay? It would do nothing.
06:53 Why would it do nothing?
06:55 Because the property cards, okay -- self.cards is how we're accessing our own property -- its getter looks like that by default.
07:05 If we don't give a getter, that's what the getter looks like.
07:07 It's just going to return this underbar cards instance variable.
07:10 Well, that underbar cards instance variable's going to start out at zero because all instance variables in an Objective-C object start out zero.
07:18 All of them.
07:19 Okay? So including pointers.
07:21 So that pointer will be zero, which is we call nil, which means it doesn't point to anything, which means there is no array, okay?
07:29 We got a pointer to an array that doesn't point to anything right now.
07:33 Okay? So that's a problem.
07:34 So when we execute the code in add cards like self.cards add object card, that's going to not crash but not do anything, either.
07:43 Okay? Because I told you that you can send messages to nil, send messages to pointers, to objects where it's not pointing to one at the time, and it will not crash.
07:53 If you send a message that returns a value, that message will not execute any code but it will return zero.
07:59 Okay? So a lot of zeros flying around here.
08:02 Okay? So how are we going to fix this?
08:04 How are we going make it so that add card works?
08:06 Well, we could put something at the beginning of add card that says, "If self.cards is nil, then go allocate an array in the heap and point to it, and then we'll use it." Okay? But that would mean every single time we have to use self.cards we'd have to go around and check and make sure it's not nil.
08:23 And that would be very annoying.
08:25 Okay? That would be very error-prone, bug-prone, we forget to do it somewhere.
08:29 All these things.
08:30 So a great place to do that little if check is in the getter, okay?
08:35 That getter that we have right there for cards -- that's the getter for our private property cards -- instead of just returning the cards, let's put a line right in front that says, "If the cards is nil, then let's go allocate one in the heap and assign it to the instance variable." Okay? So the way you allocate an array in the heap is you use NS mutable array alloc init.
09:00 So that's two message calls nested inside of each other.
09:04 The alloc allocates the member in the heap, and init initializes that memory so that it's a, you know, sensible array.
09:10 And we're going to see how we build our own initializer in a couple slides here.
09:15 So this way every single time you call self.cards, you can be sure that it's not nil; it's at least going to be an empty array.
09:22 Does everyone understand this code?
09:25 It's important to understand this.
09:27 Yeah.
09:28 [ Inaudible ]
09:37 >> Paul Hegarty: Okay.
09:37 So the question is: Instead of having this initialization code be in this getter, why don't I make an initializer like an init for deck and put this inside deck?
09:48 Okay? And that is another option.
09:50 And again, we're going to see initializer for playing card deck, we're going to make an initializer.
09:55 And we could do that.
09:57 But having the initialization of this thing be closer to the actual getting of the property is more -- it makes your init less full of a bunch of junk like that.
10:08 And this is called lazy instantiation, by the way, doing it this way.
10:13 We are lazily waiting to the last second until we instantiate.
10:18 This pattern is something everyone in Objective-C is used to, and you should definitely use it rather than doing things in your init.
10:23 In init you want to, you know, set things, set values that, you know, can't easily be defaulted like this.
10:30 Okay? But that's a very good question.
10:32 And we'll see init in a couple slides.
10:34 Okay? So this way we're guaranteed self.cards is never nil.
10:40 Yeah?
10:40 >> [Inaudible]
10:40 >> Paul Hegarty: Yeah.
10:40 So the underscore is from last lecture.
10:43 Remember that when we create a property, Objective-C automatically does this thing, assign synthesize: Cards equals underbar cards.
10:51 So in other words, it assigns an instance variable called underbar name of property to be the storage space for that property.
10:58 So that's why underbar cards are automatically created for us there behind the scenes.
11:03 That at sign synthesizes a pop up in our code, but it's there behind the scenes.
11:06 That's a very good question.
11:09 Any other questions about this?
11:11 Okay. So let's collapse down some of this stuff and look at draw a random card, okay?
11:18 So draw a random card, all it wants to do is get a random card out of that self.cards, okay?
11:24 So that code is very simple as well.
11:27 So we just get a random integer.
11:30 That's what arc 4 random does if you don't know.
11:32 It's just a C library function.
11:34 It gets a random integer.
11:35 Then that little percent after it means mod -- okay, integer modulo -- and then self.cards.count is the number of cards in our self.cards.
11:44 Okay? So we're just going to get a random index into self.cards, then assign a random card to be self.cards square brackets index, okay?
11:55 So this is that same square brackets to access an array kind of syntax.
12:01 And it's interesting, that self.cards square brackets index, actually, that's a message send believe it or not.
12:07 That's same as self.cards object at index index.
12:12 Okay? It's just some special syntax and syntactic sugar to make it so that you don't have to have long object add index.
12:18 It's actually object at subscripted index or something with a real long method name.
12:22 So this is just a beautiful, little simple syntax.
12:26 But that is a message send to get the card at that index out of the array.
12:30 And then we're also going to remove that card out of the array because this is draw a random card, okay?
12:37 It's draw the card out of the deck.
12:40 So it's not in the deck anymore, right?
12:42 Now, there's a problem with this code as well, which is: What if the deck is empty?
12:48 Okay? If the deck is empty, then that unsigned index is going to be zero, right, because it's going to be arc 4 random mod zero.
12:56 That's going to be zero.
12:58 And so you're going to say, "Random card equals self.card sub zero." Well, that's going to crash your program because if self.cards is an empty array, then there's no object at index zero and you're going to get array index out of bounds.
13:12 Okay? So be careful of that.
13:14 The index -- you cannot get the index -- if an array doesn't have an object of that index, you can't get it.
13:20 So that's easy to fix, though.
13:22 We're just going to say, "If self.cards count," in other words if there are things in the array, "then we'll do that.
13:29 Otherwise we're just going to return random card," which I happily initialized to nil at the beginning of my method.
13:35 And that's why I kind of like this thing of initialize it to the default value you want, then set it, and then return.
13:41 And that way if the setting fails for some reason like this -- it fails because there's no cards in the deck -- it will return the reasonable default.
13:48 That's just kind of a coding style thing.
13:50 Okay? We did that same thing with score and match.
13:53 Okay? Any questions about that?
13:57 Yeah?
13:58 [ Inaudible ]
14:03 >> Paul Hegarty: Great question.
14:04 So the question is: When do I use NS integer or NSU integer versus int or even NS number, which is an object which we haven't talked about yet?
14:15 And the answer is it's a matter of style.
14:17 And we'll talk a little bit about that style and when to use these things.
14:20 Here I don't really want to use an NS number which is an object when I'm just using it, you know, as a little local thing like that.
14:27 You would never do that.
14:28 You're using NS numbers basically to pass them to methods.
14:32 And even then you could pass ints, you know, and floats.
14:35 So it will be become obvious as I talk about NS number, which we'll do next week.
14:41 Okay. So that's it for deck.
14:43 Deck, very simple class as well.
14:45 So let's move onto another class, which is playing card.
14:49 Okay? The reason I'm showing you playing cards, I just want to show you what it looks like to make a subclass of another class that you've written.
14:54 So playing card is a subclass of card.
14:56 And this is the specific card like king of hearts, three of diamonds, that kind of card, okay?
15:02 Now, it has properties that are specific to a playing card, which is the suit and rank.
15:08 Okay? The rank being like a three, four, a jack, king, right?
15:11 And the suit being hearts, diamonds, clubs.
15:14 And I'm going to represent the suit as a single character -- the hearts characters, the clubs character.
15:19 Remember I typed the clubs character I think in the card we might have shown that.
15:23 I don't know.
15:23 But you can type a single character.
15:25 Unicode has a character for each of the four suits.
15:27 So that's what my suit is going to be.
15:28 And then the rank is going to be a number between zero and thirteen.
15:33 Is that king?
15:34 Yeah. Representing the rank.
15:36 So that's how I'm going to represent in my public API.
15:38 And here I'm using notice NSU integer instead of unsigned int.
15:43 So NSU integer and unsigned int are almost exactly the same thing.
15:47 The only thing about NSU integer is it's typedef.
15:50 It might be a little different on different platforms.
15:52 For example, the new iPhone 5s are 64-bit processers.
15:56 So NSU integer is going to be a 64-bit int, unsigned int on an iPhone 5.
16:01 And it might only about a 32-bit one back on an iPhone 4 and before.
16:05 Okay? So that's a little bit different.
16:08 So a minor int.
16:10 We were probably not representing integers.
16:12 Certainly here we're only going zero to thirteen.
16:14 Probably doesn't matter.
16:15 But, you know, we're not representing integers that are so gigantic that we're going to be using the 33rd bit.
16:21 So notice that in playing card we're overriding card method contents.
16:28 Okay? We inherit contents from our superclass.
16:30 And by default contents just returns the value of whatever the contents property is.
16:36 But here in the playing card we're going to override contents to actually calculate our contents, based on these other two properties.
16:43 Okay? So we're overriding the getter of contents so that it always returns a string -- the contents of this playing card -- that is calculated from the suit and rank.
16:53 You see what we're doing here?
16:54 So we're basically taking the storage of contents -- underbar contents -- from our superclass and ignoring it because we're overriding its getter.
17:01 Okay? So this is a perfectly valid reason why we do these properties as well because we might have a better way to do things than the storage.
17:10 Now, here's a way we could implement it: We can just return a string, okay?
17:13 NS string, string with format just like printf-ing a string.
17:17 Don't worry about that syntax too much.
17:19 And I'm printf-ing a string with percent D and percent at sign.
17:22 So percent D means integer; percent at sign means an object.
17:26 Okay? A string representation of an object.
17:28 And then I'm just using the rank and suit.
17:31 So this would be one way to do my contents.
17:32 It's not a very good way because, for example, the jack of hearts would say 11 hearts, okay?
17:38 It's not going to say J at least; we want to say J, not 11.
17:42 So this is not a very good way.
17:44 So instead I'm going to make an array that has all the right things like an A for a one, and a J for 11, and a Q for 12, and a K for 13, right?
17:55 So I'm just making this array here.
17:57 In the middle there I had to cut out to make it fit, right?
18:01 And I even made zero be question mark.
18:03 So if your rank is zero, it's going to be, like, question mark, like, unset.
18:07 You know, your rank is basically not set.
18:09 And then I return a string, which is taking the rank out of that array and appending onto it the little suit string, the heart, or the club, or the diamond.
18:20 Everyone understand this?
18:22 I'm kind of giving you this so you can see how we're mixing in the array notation, and message sending, and it all kind of seamlessly mixes in there.
18:31 Okay? So now contents returns J hearts, or 5 diamonds, or whatever.
18:38 Notice that our rank is really nice because if our rank is zero, which it starts out being when we say new playing card -- all the instance variables are zero so rank would be zero -- we get this nice question mark.
18:49 But our suit starts out as nil, and it would be nice if the suit also returned question mark if it was unsaid, if it was nil.
18:56 So here I'm just overriding the getter of suit to say, "If return, if my suit is nil, then return the question mark, otherwise when my suit's not nil, then return what the suit is." Okay? So I'm just kind of protecting my API to make sure I always return question mark when the rank or suit is not set.
19:17 Yeah.
19:17 >> [Inaudible]
19:18 >> Paul Hegarty: Sorry.
19:19 All little at signs -- the red at signs, you mean?
19:22 Yeah. Guess we didn't get to that in card.
19:26 But we might have.
19:27 But remember that all strings that we're going to work with in this class are string objects, not const care stars, right?
19:35 They're string objects.
19:36 And the compiler, if you put an at sign in front of a string, it will make a string object for you, okay?
19:42 So that's what those at signs do, they make all those strings be string objects because we can't put a const care star in an NS array.
19:47 NS array is for objects, so we have to put objects in there like NS strings.
19:51 Those are objects.
19:52 Okay? Good question.
19:53 Yeah?
19:55 [ Inaudible ]
20:09 >> Paul Hegarty: Yes.
20:10 Okay. That's a good question.
20:11 If we had used that getter equals notation that we used for is chosen and is matched to change the name, then when we override we have to use the new name.
20:21 We'd have to is whatever.
20:23 Now, this is not the case here.
20:25 But I know what you're saying, and yes, you would have to use the new name.
20:29 Great question.
20:30 Any other questions about this?
20:32 Okay. So that helps the suit always return question mark if the suit is nil or not set.
20:37 Let's also protect people setting the suit to something wrong.
20:42 Okay? Let's only let people set the suit using this property, the public setter of the property.
20:48 We'll only let people set the suit to be one of the four suits.
20:53 So I just on the fly in the middle there created an array of those four suits.
20:57 And then I use this method contains object; what class do you think contains object is from that bit on?
21:04 Anyone? [Inaudible]
21:04 >> [Inaudible]
21:05 >> Paul Hegarty: It's an NS array method, exactly.
21:10 So contains object is an NS array method.
21:12 I'm sending it to the array that I create right in place there.
21:15 The array that has hearts, diamonds, spades, and clubs in it.
21:18 And I'm just asking: Do you contain this string?
21:20 And that contains object is going to compare the contents of this string against all these using a method is equal.
21:27 Actually, it's going to say is equal to all four of them with the suit as the argument; not is equal to string -- is equal.
21:32 And in string is equal is implemented by calling is equal to string if the argument's a string.
21:37 Anyway, more detail than you need probably there.
21:39 But this is obviously protecting it.
21:41 So there's no way we can set our internal suit storage variable to anything except for those four suits.
21:47 Yeah?
21:48 [ Inaudible ]
21:59 >> Paul Hegarty: Great question.
22:00 You guys are right on top of it.
22:02 So every time I use the at sign open square bracket -- the blue one -- to create an array, that's actually creating a new array every time.
22:10 Okay? Because I told you that that at sign square bracket and all this array stuff is really just calling methods?
22:15 Well, that's calling a method like alloc init with array with objects or something like that.
22:20 Right? So it is creating it.
22:21 So it would be nice to move it out, and we're going to do that.
22:25 Although, again, be careful not to preoptimize.
22:28 It probably wouldn't make any different.
22:29 I'm only going to move it out to make my code cleaner; I'm not going to move it out for any performance reason.
22:37 Yeah?
22:38 >> [Inaudible]
22:38 >> Paul Hegarty: Yeah.
22:38 >> [Inaudible]
22:38 >> Paul Hegarty: The question is: Would LLVM just take care of that, optimize that out for you?
22:41 And it probably wouldn't because that's a message send; it's not sure what there might be side effects of it.
22:45 But in any case, we're just going to do it just to make our code look cleaner.
22:49 And the performance would be negligible here.
22:51 We're talking about UI.
22:52 It's not even close.
22:54 One thing to note, though, before we do that is since we've implemented both the setter and the getter of suit, we are now required to do the at sign synthesize.
23:04 Okay? In other words, normally we don't have to do this at sign synthesize.
23:08 It gets done for us.
23:09 But if we implement both the setter and the getter, now we do.
23:12 It's easy to do because it's always of this exact same form.
23:15 But we do have to do it.
23:18 Okay. So here's -- let's do what we were saying.
23:21 Let's take that little array of suits we have in there and put it in another method.
23:26 Now, again, I'm not getting any performance by doing this, okay?
23:29 I'm just getting code cleanliness by doing this because I'm still -- every time I call valid suits, it's going to create it again.
23:35 Now, I could use a static variable.
23:37 This is C. I could store this array.
23:39 Started out being nil.
23:40 If it's nil, set it to this array, and then it would only create it once.
23:44 But be careful.
23:45 Again, code cleanliness and understandably ten times more important than performance like this.
23:49 So unless you're going to call valid suits in the inner loop thousands of times, it's not really going to matter.
23:54 But once I move that up into a different method, this kind of method that I moved it to is a little different.
24:00 Notice it has a plus.
24:02 You see a plus there instead of a minus starting it?
24:06 Plus NS array valid suits?
24:08 Okay. A plus method is a class method.
24:11 Okay? That means you send it to the class, not to an instance of an object.
24:17 All right?
24:17 So since you're not sending it to an instance, you can't use any instance variables or anything like that.
24:23 You can only just kind of do generic stuff.
24:25 So the only thing we really use plus methods for, class methods, is two things really: Creating things like in the previous slide when we had string with format -- that's a class method that was creating a string for us; and then also utility methods like this, like the return constants and things that, you know, our class wants and utility methods.
24:47 But here's an example.
24:48 And the way we call the class method -- you've already seen me call a few of them -- but here's calling it here is we put open square bracket, the name of the class, the name of the method.
24:58 And again, it could have arguments.
24:59 It's just like any other method.
25:00 But everyone understand this?
25:02 Okay. And if you go back and look a couple slides and you see open square bracket NS string, string with format, same exact type of syntax.
25:12 Okay? So that's what a class method looks like.
25:13 Again, for creating things basically and for utility methods.
25:19 And we'll talk about the difference of: When do we create something with a class method versus alloc init?
25:23 We'll talk about that soon.
25:25 I'm also going to make valid suits public.
25:28 And that way people who are using my playing card know what the valid suits are.
25:33 And all I need to do is put it in the header file.
25:35 Boom, it's public now.
25:36 Okay? So let's do a similar thing here with those rank strings.
25:41 Okay? So I'm going to take those ranks strings -- that array of rank strings right up there -- and I'm going to put that in a class method.
25:49 Okay? And again, this is for readability, not for performance.
25:52 Because every time I call rank strings, it's still going to create that thing again.
25:56 And then I call it instead up there.
26:00 And I'm not going to make rank strings itself public, but I am going to make another class method called max rank, which just looks at how many strings are in rank strings.
26:09 And I'm going to return that as a public method.
26:13 So there's three class methods for you to sink your teeth into -- two of them public, one not.
26:19 All right.
26:20 And so they're all utility methods, right?
26:22 We're not accessing any instance variables in any of those methods, okay?
26:27 That's the only reason I'm showing those, is just so you see what a class method looks like.
26:31 We also could override the setter of rank just to be complete here to make sure it doesn't allow you to set a wrong rank like set rank 15 -- there's no such card as 15.
26:42 So let's make sure that the rank is less than the max rank, which is the utility method we just did.
26:47 Okay? Does that all come together for you, make sense?
26:50 So this is kind of reference material.
26:53 You have these slides that have all the annotations of all the things I'm saying.
26:56 So feel free to go back and look at it and remind yourself about all these NS array, syntax, and all the class methods, all that stuff.
27:04 Okay. The last thing we're going to look at is the init method business.
27:08 Okay? So we're going to have another class here called playing card deck.
27:12 All right?
27:12 And a playing card deck is a subclass of deck.
27:14 All right?
27:15 And it has no public API.
27:18 It's just going to override a method that it inherits indirectly from NS object -- okay, NS object through deck, which doesn't touch it -- all the way to playing card deck.
27:29 And that method is called init.
27:32 Okay? So this is the same init, same kind of method that when we created that array -- that mutable array we said NS mutable array alloc init.
27:41 So someone is going to call this playing card deck init method -- namely you in your homework are going to call this by doing playing card deck alloc, and then on the outside, init.
27:52 Okay? And that's how you're going to create a playing card deck.
27:55 And that is how we create most instances of objects -- not all.
27:59 Sometimes we do things like the NS string, string with format.
28:02 But most of the time -- more than half the time -- we do alloc and then on the outside init.
28:06 Okay. Listen carefully: Never call that alloc thing without wrapping an init around it.
28:13 Okay? Don't ever do that.
28:14 That makes no sense to have an object allocated in the heap that's never been initialized.
28:18 Always have that nested.
28:19 And vice versa: Never call that init except for when you wrap it around an alloc.
28:25 And definitely never call that init more than once.
28:27 Okay? And if you obey my rule of only calling it wrapped around an alloc, you can't call it more than once.
28:32 Okay? Init is not something like you can re-init.
28:36 Init happens once right after alloc, and that's it.
28:39 Okay? That is a hard and fast rule we never break.
28:43 Okay? So you heard it here.
28:45 Don't forget.
28:46 All right.
28:46 Let's look at the whacky return type to this init method, okay?
28:50 You might think this init method should return a playing card deck star because it's kind of initializing and maybe it returns itself.
28:58 And in fact, init does always return self, okay?
29:02 So init is always going to return self.
29:04 Okay. More whackiness there, which I'm going to describe.
29:07 Just for convenience, it always returns self so that you can do, like, playing card deck alloc init, sent it a message.
29:14 Okay? So it's just convenience that it returns self.
29:17 But it can't really have its return type being playing card deck star because it inherited this from NS object.
29:23 And NS object already defined it as NS object star.
29:28 You see? So it's kind of weird that you're inheriting a method whose return value would have to change every time you, you know, overrode it.
29:36 So they invented this new thing -- this is new for iOS 7, by the way -- called instance type.
29:42 And what instance type means is this is going to return an object that is of the same instance -- same type, same class type -- as the object you sent this message to.
29:52 Okay? Which makes perfect sense for inits.
29:54 And in this class that's probably all you're going to use this for right here.
29:58 So if you don't really understand what I just said -- it's explained in the slides -- but if you don't really understand it, just know that whenever you do an initializer, it's going to return instance type as its return type and you're always going to return self.
30:10 Okay? Now, also just take my word for it.
30:14 We're going to do these next lines of codes as well because they are really strange.
30:18 That first line, self equals super init, that is weird.
30:21 That is super weird.
30:23 Okay? Assigning something to self in Objective-C -- just never do that, except for this one time and that's in your init.
30:30 Okay? You take self and you assign it to calling your superclasses initializer so that your superclass gets initialized.
30:37 Why do we assign the result to self?
30:41 It's kind of ancient history as to why this has been done for a long time.
30:45 Basically we're checking the return of our superclasses init to make sure it properly initialized.
30:50 Because at any time if your initializer cannot initialize itself, it should return nil.
30:57 Okay? And that lets everybody know any of your subclasses or anyone trying to alloc and initialize you, you could not create a well-formed object.
31:05 Okay? So you can see how this code, strange as it is -- self equals super init, and then if self, I'm going to initialize myself, return self -- that's going to ensure that I don't even try to initialize myself if my superclass, when I call its init, you know, can't initialize itself.
31:21 Okay? So just do it.
31:24 If you don't understand it, don't worry about it too much.
31:27 Just do it.
31:27 Now, one thing here is we're talking about init with no arguments.
31:31 It is possible to have initializers with arguments because sometimes you need arguments to properly initialize a class.
31:36 And we're going to talk about that a little more on Monday.
31:40 Okay? So today we're just going to kind of bare bones init.
31:43 So what does this init need to do?
31:45 What do I need to do to have a well-formed initialized playing card deck?
31:48 Well, a playing card deck has 52 cards in it, one of each kind of card.
31:53 Okay? King of clubs, three of diamonds -- all 52 of them.
31:57 So I just need to iterate to all the suits, and then iterate through all the ranks, and create a card, and add it to myself.
32:06 So here's me iterating through the suits, iterating through the ranks.
32:09 Everyone cool with that?
32:12 Then I'm going to import playing card because I'm going to create a playing card, playing card alloc init.
32:20 Then I'm going to set that card's rank, set that card's suit.
32:23 Rank and suit are my little iteration variables there.
32:28 And then I'm going to add it to myself.
32:31 I'm a deck, so that's perfectly fine.
32:35 Everybody cool with that code?
32:39 So now I'm a well-formed playing card deck and I can be used to draw random cards and all that stuff, which you will need to do for your homework.
32:47 Okay? And in fact, for your homework you're going to have to type all four of these classes in.
32:51 I want you to get experience entering classes, typing a thing, watching as Xcode complains at you as you mistype things, and stuff like that.
32:59 And then you're going to be using playing card deck and playing card.
33:03 Well, playing card deck and card really are the two main ones you're going to be using to do your homework.
33:08 Okay? Questions about that?
33:11 Okay. So that's it for the slides.
33:14 So now I'm going to do a big old demo.
33:16 And this demo is going to integrate everything you've seen so far, okay?
33:21 Most notably that MVC stuff we talked about, like target action, you know, dropping the target and shooting the action or the green arrow outlet that points the other way.
33:30 Okay? We're going to show you what that actually looks like in Xcode.
33:34 I think when I asked who of you have done Xcode, almost every single one of you raised your hands.
33:39 So I'm not going to spend too much time talking about all the buttons in Xcode.
33:42 I think I'll quickly pass over those.
33:44 But if you haven't used Xcode, it's in very much detail in the lecture slides.
33:49 There's kind of this walkthrough.
33:51 By the way, if you're following along in the lecture slides, my demo's not going to be exactly like what's in the slides.
33:57 The slides cover a little bit more than I can cover in forty minutes here.
34:00 And it's also reference material.
34:03 Okay? So if I do something today in this demo and you're like, "Oh, how did he do that?" if you go look in those slides, it will tell you.
34:10 So do not feel like, "I got to furiously write down every button click he's going to do in the next forty minutes." No way. Okay?
34:16 Follow along in those slides if you want, or just close your laptop, and watch, and let it sink in because you're going to have to reproduce what I'm doing in the next forty minutes for your homework.
34:28 And those slides are going to walk you through step by step how to do it.
34:31 So do not feel like you need to do anything right now but let this all sink in.
34:35 Get a feel for what's going on.
34:37 Okay? And then when you sit down to do it, you'll be guided through it.
34:43 Next week we're going to talk a lot more about Objective-C, answer some of these more detailed questions like NS number and some of these other things people are asking.
34:50 And we'll talk about some of the specific things about Objective-C like dynamic binding, and protocols, and things that you don't generally see as much in other languages or don't exist in other languages.
35:02 So we'll try and cover all that.
35:04 So by the end of next week you're up to speed in Objective-C.
35:07 You're starting to really run with Xcode.
35:10 And so the week after that we can really start doing some, you know, high power iOS 7 stuff.
35:18 Okay. So demo here.
35:21 [Inaudible] that.
35:22 All right.
35:23 So the demo I'm going to run in Xcode.
35:25 So I'm just going to launch Xcode.
35:27 So Xcode you get by running -- going to your Mac app store.
35:32 That's this thing down here, right?
35:34 Get the app store on your Mac, and you just search for Xcode, find it.
35:37 It's free.
35:38 You download it and you run it.
35:39 Okay? It's as simple as that.
35:40 This is what it's going to look like when you first bring it up, this splash screen here.
35:45 As the quarter goes on, this will fill up with all the projects that you're doing.
35:50 You're probably used to that if you know Xcode.
35:52 And what we're going to do today is create a new project.
35:55 You can either check an existing project out of source control or you can create a new one.
36:00 And so we're going to create a new one.
36:02 So when we create a new one, it wants to give us a little bit of help by offering to create a template for different kinds of applications like an openGL game.
36:11 Okay. It will create some framework for that for you.
36:16 Master detail applications, something we're going to do later in the quarter, although we're going to build all the code ourselves; we're not going to use this template.
36:23 And this single view application one right here is basically a single MVC, which is how we're going it start all of our applications in this classroom -- with a single MVC.
36:33 Then we're going to add more MVCs and build up.
36:35 Okay? So this is your basic single MVC app.
36:39 So I'm going to click that.
36:40 And here it's going to ask for some information about it like what do you want to call this app?
36:45 This is a card matching game I have decided to call Machismo, okay?
36:49 So that's going to be the name of our app just for fun.
36:53 And organization name can be anything you want.
36:55 It's going to appear in the headers of all the classes that you create.
37:00 So I make mine be Stanford University.
37:01 You can make yours be Bob's Game House or whatever.
37:05 This identifier should be unique to you.
37:09 So I have edu.Stanford.cs193p.instructor.
37:13 You might have edu.Stanford.cs193p dot your SUNet ID.
37:16 That will be completely unique.
37:19 These reverse DNS is a really good way to create a unique name.
37:23 And it's going to create a unique name for this app by combining this with the names.
37:28 So you can see it's done that here, this bundle identifier.
37:31 And then this class prefix -- this template is going to create a view and a controller for us.
37:38 And this is saying, "What do you want the name of your controller class to be?" By default it's going to be called "view controller," okay?
37:45 But if you type something here like "card game," now it's going to be called "card game view controller," which is a little better name for us.
37:53 So that's just the prefix it's going to put on the name of your controller that it creates for you.
37:56 And then finally here we can create an app here just for iPad, or just for iPhone, or a universal app that will run on both platforms.
38:05 Now, when you create a universal app, you still have to design your UI's separately because if you have more screen rules, you're just going to design a different UI.
38:13 Okay? iPad is not just a big iPhone.
38:15 You can do a lot more stuff if you have more screen real estate.
38:18 But you still might have a lot of your MVC's shared, right, because that iPad might have little subareas that are in MVC that are exactly the same as on an iPhone or very, very similar.
38:29 So totally supported in iOS 7 to build apps that target both platforms and has great tools for letting you build your two UI's separately and share all the MVCs underneath.
38:40 Okay? We're going to do iPhone only here just because it keeps the screen small and I only have so much real estate here.
38:46 [ Inaudible ]
38:52 >> Paul Hegarty: Yeah.
38:52 So the question is: If I'm on my iPad and I run an app that's iPhone only, yes, there's an emulation mode essentially that will kind of make a big iPhone-shaped thing on the iPad screen.
39:04 So we're going to do iPhone here.
39:05 So that's it.
39:06 I'm going to hit next.
39:07 Next it wants to know, "Where are you going it put this project?" I strongly recommend putting it in your home directory -- in a directory called "developer" in your home directory.
39:17 Okay? Unless maybe we're working on different class.
39:19 Maybe you have the CS 193P in your home directory and then other class.
39:23 But bottom line: Put it in your home directory; do not put it, like, in root or somewhere like that.
39:28 That has in the past caused problems.
39:31 But a great place to put it here.
39:32 This is my home directory, CS 193P there.
39:34 I see home directory, developer.
39:37 This is where I'm going to put it.
39:38 I don't have any projects yet.
39:39 This little thing down here, source control, we will be talking about that.
39:43 It's really nicely integrated into Xcode, but we're not going to talk about it today.
39:47 So leave that unclicked.
39:51 And so here's our new project.
39:53 You can see it shows us this screen, which you get to by clicking on this very top thing up here.
39:58 So this is kind of like our project settings.
40:00 And there's a whole bunch of settings here.
40:02 We'll be talk being all this stuff as the quarter goes on.
40:04 But today we're not going to talk about any of it because we want to focus on our MVC.
40:10 And our MVC, this right here, main.storyboard, is our view.
40:15 Okay? That's our view of our MVC.
40:17 And then you see this card game view controller M and H?
40:21 That's our controller.
40:23 There's no model here.
40:24 Your model is going to be those four classes -- deck, card, playing card, playing card deck -- that's going to be your model.
40:31 So you'll have to enter that in.
40:32 I'll show you at the end how to do that.
40:35 This little thing here, card game [inaudible] dot H and M, we'll talk about that briefly, especially when we start talking about things like multitasking.
40:44 But I like to just move those out of the way.
40:46 So I often put them down here in this supporting files folder.
40:49 And you can just pick up any file, by the way, and move them anywhere you want here to kind of clean up your view.
40:55 So here I've got my view and my controller only showing here.
41:00 Okay? So let's go straight to the view and see what that looks like.
41:04 So here's my view.
41:05 It's a blank iPhone 5 sized, right?
41:09 A tall and thin view.
41:13 And it's blank.
41:14 Nothing new.
41:14 It's white.
41:15 This area on the left, by the way, where we clicked on these files, that's called the "navigator." And you can not only navigate all your files here, but you can navigate your break points, and build problems, and your class hierarchies.
41:28 All that stuff up here.
41:29 So again, most of you know Xcode, so you probably know most of this stuff.
41:32 We'll be demoing all this as the quarter goes on.
41:35 And this area over here is called the "utilities area." And this is where you basically find out detail about what's going on here.
41:43 So inspectors for attributes, and dimensions, and connections, and things like that go here.
41:50 And this is also where you can drag out the things that you're going to use to build your user interface because we're going to build our view entirely graphically.
41:59 Okay? We're not going to write code, for the most part, to build our view.
42:02 As the quarter goes on, we'll learn a little more about how to build our view in code, but we're going to start out just purely doing our view by graphically dragging things out and wiring them up.
42:12 And we'll put our code in our controller.
42:14 This two sides can be hidden and shown with these two buttons.
42:21 See? You can hide those.
42:24 [Inaudible] This might appear also, this area right here, this little button down here.
42:29 This is called the "document outline." This is really handy dandy.
42:32 But again, we're not going it talk about that today.
42:33 We can only talk about so much at once.
42:35 The document outline.
42:37 This just shows you all the instances of objects in your view in a common outline form.
42:42 So you can really easily find them and their relationships to each other.
42:45 The other thing you can do is I don't want this iPhone 5 sized thing because my screen is low resolution here so it works on the projector.
42:54 So I'm going to click this little button down here, which reduces me down to iPhone 4 size.
42:59 Okay? Or iPhone 4S.
43:01 Now I'm tall and thin.
43:03 But you can click back and forth and move them back forth.
43:06 And I'm just trying to make everything fit on screen here.
43:11 Okay. So let's just dive right into building our view here.
43:14 What our view is going to be today is a single card with an ace of clubs written on it.
43:21 Okay? That's going to be it.
43:23 And I'm going to be able to click on the card and it will flip over, show the back of the card, and then click on it again, it will flip back to show me the ace of club again -- back and forth, back and forth.
43:31 Okay? And your homework is going to be to make it so when the card flips up it doesn't show the ace of clubs, it shows a random card drawn from the deck.
43:38 Okay? That's going to be your entire homework that's due on Monday.
43:42 Okay. So let's do this.
43:43 Really simple.
43:44 We go to this area right here, this object library.
43:47 Okay? That's the third button over here, show object library.
43:50 And this is where all our objects are.
43:52 If you look in here and you don't see these objects, it might be worth clicking on your view.
43:56 Sometimes Xcode wants to know what the destination is that you're going to be dragging things into.
44:02 So if you click on it, then you'll see these things.
44:04 And we're just going to grab one of these buttons right here.
44:06 So I'm going to pick this button up and drag it out.
44:09 And notice, as I drag it out, these little blue lines appear -- these guidelines.
44:13 Okay. These guidelines are super important.
44:16 They seem just like a convenience for helping you put it right in the middle or right in the right-hand corner.
44:21 And they are, but they're really important for making sure that all the things in your view are kind of, like, standard space apart, right?
44:30 And lined up against edges.
44:31 So that as the users go from one app to another, things will all be separated by predictable spaces and everything will be consistent.
44:38 It's really important.
44:39 And there's a mechanism -- you can see this switch right here, use auto layout, which was introduced in iOS 6 and vastly improved in iOS 7, especially in Xcode -- that allows when your user interface changes size, like it goes from being an iPhone 4 to an iPhone 5, or it rotates from being vertical to being horizontal, or it's on an iPad in a bigger space.
45:02 For all the buttons and everything to kind of move to a new position that makes sense or at least most of them, right?
45:08 And then maybe you might have to move a few of them by hand, depending on what's going on.
45:11 But it mostly automatically lays it out.
45:14 And this is really important because I'm sure devices will continue to be differing sizes as new, you know, devices come out over the years.
45:20 So doing auto layout is important, and these blue guidelines are the number one most important thing for auto layout.
45:26 We're going to cover auto layout in detail, and there's a lot to it.
45:29 All these buttons down here have to do with auto layout.
45:33 But getting those blue guidelines, making sure you drop things with at least one blue guideline somewhere is really important to kind get you going down the right path with the properly auto laid out UI.
45:43 So we have this button here.
45:45 But before -- and of course, we can go over here to this is the attributes inspector and click on it.
45:50 And we'll see all kinds of attributes.
45:52 In fact, if I hide this, tons and tons of attributes for this button.
45:56 Okay? Not just the button itself, but actually its superclass has attributes.
46:00 Control is its superclass, and then view is control's superclass and it has attributes.
46:05 Okay. So this is an objective-oriented inspector that will show all the attributes of all the things through the inheritance hierarchy.
46:14 And what's happening here is we're actually editing an instance of a button here.
46:20 So we are not -- and I know in some systems you layout the button, you set the size, and you set the attributes.
46:25 And then, you know, behind the scenes a bunch of code is being generated to create the button.
46:30 That's not what we're doing here.
46:31 We're actually editing live objects.
46:33 They're essentially going to be freeze dried.
46:35 And then when your app runs, add water, they come to life, okay, with their attributes set, and all their sizes and positions, and all their auto layout information in the object.
46:44 Okay? So it's a little different than you might be used to in some other systems.
46:50 So anyway, before we edit the attributes of this button, though, let's change our background because this is a card game.
46:56 And most card games are on, like, green felt, right?
46:59 So let's make our background be more like a green felt.
47:01 So I'm just going to click on the background, which is this view right here, and you can see its properties.
47:06 So I'm going to change a couple -- or just one of its properties -- which is the background.
47:10 You see this background white color right here?
47:12 So if I click on this, I have some recently used colors.
47:15 I have all these kind of black and white colors.
47:18 And I also have other.
47:19 And I bring up other, brings up the crayons, okay?
47:22 It also brings up other ways to choose colors, but I like the crayons.
47:26 Okay? And so where are my crayons?
47:29 There they are.
47:30 So let's pick a green, like, moss is a good green.
47:34 Clover. I kind of like moss better.
47:36 So that's kind of a card game background.
47:39 And that's it.
47:39 So we've set the background color of our views.
47:43 Okay? And all the attribute setting is just like this: You just set it and forget it.
47:48 So let's go back to the button and its properties.
47:50 Okay. The button I want to look like a card.
47:53 Well, a button in iOS 7 basically looks a lot like a hyperlink on a web page, just like that button does right there.
48:00 Okay? That blue button.
48:02 That's not really appropriate for what we want.
48:04 We want it to look like a card with a little rounded rect and a white background, right?
48:08 And I want the back of the card to look the same but have some kind of design on it or something like that.
48:13 So the way I'm going to do that is I'm going to set a background image for my button.
48:18 Okay? A background image that's like a rounded rect.
48:20 So let's take a little aside here and talk about: How do we get images into our app?
48:25 Okay. We want to use images in our app; it's very common to want to use images in a graphical application like on a phone.
48:31 So how do you do it?
48:32 And the answer is you go down here to this place called the "image asset library" -- images.xc assets or Xcode assets.
48:40 And you can see there's already a couple of slots for icons here.
48:43 They're not set, but this is the app icon.
48:45 And also you can have a launch image that will appear instantly when someone launches your app.
48:49 And then as you're initializing, having behind the launch image, and then it will show you are actual UI.
48:54 So it's kind of quick launch image.
48:56 And we'll talk about this on Monday.
48:58 We'll set the app background for Machismo here.
49:00 But I'm going to actually drag in some other image.
49:04 So I have some images here.
49:05 And for example, I've got this Stanford logo right here.
49:11 So I'm going to drag that Stanford logo in because I want to use it.
49:15 And that's it; you just drag it in here.
49:16 It says Stanford.
49:17 But notice that it kind of has this weird thing here, this 1X and 2X.
49:21 You see that?
49:21 And that's because every image that you're going to use in iOS wants to have a normal resolution version that's going to be used like on the iPhone 4 -- nonretina displays basically.
49:33 And then a 2X, twice as high resolution -- one that will be used on retina.
49:38 And it will automatically pick the right one, depending on what you're running on.
49:41 Okay? You don't have to do anything about it.
49:43 But you do want to provide these higher res ones.
49:45 And these higher res ones aren't just necessarily the same exact image, just, you know, made more high resolution.
49:53 They might allow you to do -- for example, here I've got a Stanford logo with the little tree.
49:57 See? See the tree in there?
49:58 So maybe this is too low resolution to really get a good-looking tree.
50:01 But I can get the tree in at a higher resolution, so I put it in there.
50:05 So it's not that common that the two ones would be actually different-looking but they could be.
50:09 Certainly allowed they could be.
50:11 I also don't want to really call this "Stanford." I'm going to use this as my backup card.
50:17 Instead of having, you know, some kind of design, I'm going to have the Stanford logo be the back of my card.
50:21 When my card's flipped down and I see the back, I'm going to see the standard logo.
50:24 So I'm going to call this "card back." I can call it anything I want.
50:29 I also have things for the front here.
50:32 This one right here.
50:33 This is blank card with a rounded corner.
50:35 There it is.
50:36 You can't see it.
50:38 Because it's a white card so you can't see it.
50:40 But I'm going to use that.
50:41 I'm going to call this "card front." And I'm also going to have a high-res version of that as well.
50:48 Okay. So that's good.
50:50 So as much as we can see of it.
50:53 Okay. So now I got some images.
50:56 And now I want to use them in my view.
50:58 I kind of want to set this card to use this.
51:00 So I'm going to start with my card here being face up when it runs.
51:05 When my app runs, the card's going to start face up.
51:08 In your app when you get your homework you're probably going to want to start it facedown.
51:12 The reason for that is my app only shows one card: Ace of clubs.
51:16 So it's fine if it comes up with ace of clubs.
51:19 But you don't want your card to come up ace of clubs for sure.
51:22 And it might be a little more work for you coding-wise to initialize it to come up with some random card.
51:27 So I'll just have it come up facedown.
51:29 Make it a lot easier on you.
51:30 Okay? So how do we set that?
51:33 Really simple.
51:34 I've got the button selected here.
51:36 Here's its properties.
51:37 One of its properties is its background image.
51:40 Okay? So I'm just going to click here, and you can see that all images that are in my assets library will be here.
51:45 Okay? And if there was a really lot of them, you can type and it will match it.
51:48 So I'm going to make it be the card front.
51:51 So it made it the card front, but I don't see -- where's the rounded rect?
51:55 Okay? I can't see the rounded rect.
51:56 And that's because it's too small to see the rounded corners very well here.
52:01 So you can just take this thing and resize it.
52:04 Okay? And I'm going to make it -- I want it to be about two to three [inaudible].
52:10 So I'm going to make it 64 by 96.
52:12 I know this happens to be a very good size, and I've resized it.
52:15 And now you can see the little rounded corners.
52:18 You see? So this is that image I dragged in with button written on top of it.
52:22 And of course, I moved it a little so I can put it back in the middle using my blue guidelines, right?
52:27 And of course, I don't want my card to say "button" it; I want the ace of clubs on here.
52:31 So I'm going to just double-click on it.
52:33 I could also edit that up here.
52:34 You see right here where it says "button"?
52:36 Click it here.
52:36 I'm just going to double-click directly on it.
52:38 I'm going to type "ace." And how do I type clubs, anyone know?
52:42 Alt something or other.
52:44 I like to do this way.
52:45 I go to edit menu, special characters, get this magic thing.
52:49 You ever seen this, kind of cool?
52:51 Just double-click -- find the clubs and double-click.
52:55 All right.
52:56 So there's my ace of clubs.
52:58 Now but, you know, that's not quite right, either.
53:00 I don't really like that blue A.
I really want the A to be black.
53:04 And it could be a little bigger.
53:05 There's more room for it.
53:06 So I can go over here, for example, and change the font.
53:09 I can change it by clicking this little thing to make it bigger, or I can actually click on this T and even set which font it is.
53:16 One thing that's really important in iOS 7 is the typography.
53:20 Okay? Picking the right text styles is really, really important in iOS 7.
53:25 And we're not going to really talk about it here; we're just going to use the system font.
53:28 But that's something we'll talk about in lecture, is making sure you pick the right fonts in the right places to make the UI look really nice.
53:36 I can change the size here, maybe 24 point or something like that.
53:40 That will still fit.
53:41 And then I don't want this blue, so that's this text color.
53:44 So let's go ahead and make that black.
53:46 All right.
53:46 So I got the card looking the way I want.
53:49 That's good.
53:49 All these properties that we're setting, by the way, if you look at button, you see this state config right here?
53:55 Default? We can actually set all these things differently for the highlighted state of the button, or a selected state, or disabled state.
54:03 But we're setting these as the default.
54:05 So all our buttons always going to be displaying the default state.
54:09 Okay? So buttons are pretty powerful.
54:11 You can have them look different as they highlight or whatever, but we're going to be working all in what's called the "normal" or "default" state of the button.
54:18 You'll see that when we get to the code.
54:20 So we can actually run this right now.
54:22 So running.
54:22 You've all -- most, again, done Xcode.
54:24 You know how to run.
54:25 It's this little play button.
54:26 You can actually hold it down, and there's other things you can do like test and analyze.
54:30 But we're just going to run.
54:31 So I click run, and it's going to run this in a simulator.
54:36 Okay? And here it is.
54:38 And you can see that the simulator's so big it doesn't even fit on my screen.
54:42 So I kind of have to scroll around in it.
54:44 And when I click it, it doesn't do anything.
54:48 Okay? So that's not good.
54:49 All right.
54:50 Because I haven't put any code in my controller to respond to that thing being touched.
54:54 So that's what we're going to do next.
54:57 So let's go back here and stop.
55:04 Okay. So how do we do that?
55:05 Well, it's pretty interesting how we do that, actually.
55:07 I'm going to make some more space here.
55:09 And what we need to do is connect up to our controller.
55:14 And we do that by putting our controller's code side by side with our view.
55:18 All right?
55:19 So I'm going to click this little button right here, this button icon, and that puts side by side.
55:25 And by default if you have a view up here on the left, it's going to put that controller's code on the right.
55:31 And you can move this to get more space for the code if you want.
55:34 You can also switch between the header if you want to do public stuff or the implementation.
55:40 Okay? So that's good.
55:43 Now, this code right here is part of the view controller lifecycle, which we're going to talk about in two or three weeks.
55:48 But today we're not going to talk about it.
55:53 So we can just get rid of it.
55:55 And let's just start by saying, "When this button gets touched, we want it to flip over." So we need to make a connection between our view and the controller.
56:04 And we're going to do that thing where we hang the target out and shoot the arrow.
56:08 Okay? Called "target action." And this is going to be kind of whacky.
56:11 You're probably not even going to believe this when you see it.
56:14 The way to do this is you hold down the control key.
56:16 So I'm holding down the control key, and I'm dragging a line from the view directly into our code.
56:25 All right?
56:26 Okay? And I let go.
56:28 And it says, "Oh, you want a connection between your view and your controller, do you?
56:33 Here's what I need to know." So it's asking us, "What you do you want to call this connection?" So this is going to be the name of the method.
56:38 It's actually going to create a method here that gets called when the button gets touched.
56:42 I'm going to call it "touch card button." That's a good name.
56:45 Here it's saying, "What you do you want the type of the argument to be?" We'll talk about this later, but for now we obviously want the argument to be the button that is sending us this action, okay?
56:54 Which is going to be nice because then we're going to talk back to it and tell it to flip itself over.
56:58 There's other things we can set here like: What kind of event do you want to send this action?
57:03 And you can actually set it so there's no argument, it just sends touch card button with no arguments.
57:08 But here we want it to have the argument of the sender, the button sending this message.
57:12 You can even send the touch event along, but we almost never do that -- a tenth of a percent of the time.
57:17 So here I'm going to have the sender.
57:18 So when I click connect, it creates a new method.
57:21 And that method is wired up to that button.
57:24 In fact, you see this little round circle?
57:26 If I mouse over it, it will show you that's what it's connected to.
57:31 Okay? So this is just some pretty normal-looking method right here.
57:35 The return type, IB action, that's actually typedef void.
57:40 This method actually returns void.
57:42 The reason that Xcode puts IB action there and typedef's IB action to void, it's just so that it can tell which methods are target action so that it can do stuff like this.
57:52 Okay? The mouse over.
57:54 But the compiler ignores it.
57:55 The compiler sees it as void because it's typedef to void.
57:58 It's purely an Xcode thing to this IB action thing.
58:01 And then you can see this method has one argument, which is the sender.
58:05 That's the button sending us this message.
58:06 And it's going to send this message every time a touch goes up inside the button.
58:11 Touch up inside, right?
58:12 That was the event.
58:13 So that's when it's going to send this message.
58:15 So that's perfect.
58:16 That's what we want.
58:17 So every time this happens, what do we want to do?
58:19 Well, we want to flip the card over.
58:22 Okay. So let's start by just flipping it over to the back.
58:24 And the way we're going to do that is we're going to create a local variable called "card image." Okay. And you noticed it was trying to help me type there, and you're going to see a lot of helping here.
58:34 And UI image is another class in iOS, okay, just like UI button is a class.
58:39 UI image is the class, as you can imagine, stores an image.
58:42 Could be a JPEG image, could be an animated GIF, it could be a TIFF image, whatever.
58:47 Okay? So it's very powerful image holding class.
58:50 And it has a class method called "image named," and you give it a string like card front or card back, right?
59:00 And it will look in the assets library and give an image of the right resolution, depending on whether it's going to be go on -- actually, it will give you an image with both resolutions.
59:08 And then depending on where you display it, it will, you know, pick the right resolution, whether it's on a retina or not.
59:13 So that's cool.
59:14 We got the image.
59:15 So now we're just going to tell the button to set this as its background image instead of whatever's on it right now.
59:22 So to talk to the button, we do open square bracket sender.
59:26 Right? You see that the sender is the button sending us this message.
59:30 Okay? Set.
59:32 Okay, I'm going to start typing set background.
59:36 And you see as I start to type, Xcode is suggesting to me what I might want.
59:41 Now, it knows that the sender's a UI button, so it's only suggesting button methods here that start with set B -- set background color, set background image, and set bounds.
59:51 Okay? Notice I'm also getting some help at the bottom.
59:54 See, isn't that cool?
59:55 A little one or two lines of help?
59:57 And I could click on this link and it would take me to the documentation.
59:59 We're not going to do that for time reasons.
01:00:01 But I can also just click one and it picks that one and immediately selects the first argument.
01:00:08 So I can take that.
01:00:10 Okay? So I'll do that.
01:00:11 Card image.
01:00:12 And notice here when I type CA, there's a lot of things that start with CA that could go there.
01:00:18 But Xcode's pretty smart.
01:00:20 It knows that a local variable is much more likely what you want here than all these other CA -- functions that start with CA.
01:00:27 So it automatically selects that for me.
01:00:29 And if I hit tab, by the way, it's going to basically escape complete it.
01:00:34 [Inaudible] And if I hit another tab, it goes over here.
01:00:37 This little four state thing is just what I was talking about where you can set this for the highlighted state, or the selected state, or disabled state.
01:00:45 We're just going to do the normal or default state of this button.
01:00:49 Okay? So we're setting the background image for this button.
01:00:52 And we also need to set the title because we don't want to see that ace of clubs when we flip it over backwards.
01:00:58 So I'm just going to set it to that.
01:01:01 Okay. That's the empty string.
01:01:02 I could also say nil there.
01:01:04 Okay. But I'm saying empty string just to see what empty string looks like.
01:01:07 So actually if we run this, command three.
01:01:14 Okay, let's try that.
01:01:14 Oh, cool. [Inaudible]
So there you go.
01:01:19 So there's a miniature version of it.
01:01:21 Okay. So here's our card.
01:01:22 And if I click on it, oh yeah, it flips over.
01:01:26 Yes. Stanford logo with the tree.
01:01:29 But now if I click, it doesn't do anything else; it always flips over to the back, which is exactly what our code does, right?
01:01:35 So that's good.
01:01:36 So let's fix it so that it flips both ways.
01:01:39 Okay? And I'm going to do that by saying if the -- actually, I'm going to do one other thing first to make this code a little simpler is instead of having this local variable, I can just take this and pop it right in there.
01:01:52 Okay? And that's very common to do that.
01:01:55 And if I wanted to wrap it, it will automatically wrap if I make this too short.
01:01:58 But I can also put a return in there.
01:02:00 And when I do, look what it does with the colons.
01:02:02 See how it lines the colons up?
01:02:05 It will always do that.
01:02:06 If you press return in the middle of a message send that has multiple arguments, it will line the colons up for all the arguments.
01:02:12 Really cool.
01:02:12 So you can see all the arguments lined up left and right.
01:02:16 So anyway, I'm going to check to see if the current title -- okay, that's a button method -- if it's a string.
01:02:25 If that length, okay, is nonzero, okay -- so that's testing there to see if the length of nonzero -- that's a cool way to do it because that will work if the button title is nil or it's if the empty string.
01:02:41 Because the button title starts out nil.
01:02:43 If you don't set it to anything, it starts out nil.
01:02:45 So here with one line of code I've checked both the initial state possibly -- not in our case because we set the title to the A club -- but in your case it might be.
01:02:53 Then we'll set it to one thing, else we'll set it to the other thing.
01:02:57 So we just wanted to set this to this.
01:03:00 All right?
01:03:01 So if there's a title on the button, in other words it has the ace of clubs, then we're going to switch over to the back.
01:03:07 And if there's no title on the button, then we're going to switch back to the front.
01:03:13 Okay? Ace of clubs.
01:03:17 Okay? So now when we run, our card will flip both ways.
01:03:27 Okay? So really simple to wire stuff into your controller to do what you want.
01:03:32 The next thing we're going to do is in the -- okay, I'll show you really quickly here.
01:03:40 If you hold down the option key, a very important key, do you see how it puts a question mark and starts highlighting things?
01:03:45 That's going to allow to you to transition into the documentation.
01:03:49 So if I want to know more about this current title, if I hit option, click on it -- see, I get a little bit of help right here.
01:03:55 It's a property.
01:03:56 It's read-only, it's nonatomic.
01:03:58 By the way, if you see "retain" in the documentation, that's the same as "strong." Okay? Retain is the same as strong basically.
01:04:04 Little bit of description here but also hyperlinks.
01:04:07 And if I click on one of these hyperlinks, like this one, it takes me into the documentation.
01:04:11 This is a separate window right here.
01:04:13 And you can navigate around in this documentation.
01:04:16 You really want to get familiar with all this.
01:04:18 I can't really show it all to you today for time constraints, but you can do things like search, like I can go find UI button here.
01:04:26 Okay. There's UI button.
01:04:27 I might scroll down and go to, for example, set background image or set background image for state, which we just saw.
01:04:35 Maybe I'll click to go UI image.
01:04:37 You see all this.
01:04:38 There's nice descriptions of the class in the beginning and then all the methods, etc., etc. So definitely want to become a master of that documentation.
01:04:46 You can also option double-click on things and it will send you straight to the documentation.
01:04:49 If you don't want to get the little help one first, you can go straight in.
01:04:52 So option is the key one for that.
01:04:57 Let's go ahead -- okay.
01:04:58 Notice that this little space along the bottom here appeared when we ran the application -- you see that?
01:05:05 This is the debugger on the left, and this is the console on the right.
01:05:10 Okay? And you are definitely going to be using the debugger and the console both in this class.
01:05:15 And actually, I might have time to do a quick -- show you how to do the console.
01:05:19 But anyway, you can hide it by dragging it down or also by clicking this thing [inaudible].
01:05:23 All right.
01:05:25 So the next thing we're going to do is we're going to put a little label on our UI that counts the flips.
01:05:31 Okay? A little incremental thing that increments every time there's a flip.
01:05:35 And we do that by going back to here and grabbing ourselves a label.
01:05:43 So a label is a read-only piece of text, noneditable text.
01:05:47 And I'm just going to drag it over here and put it in the lower left.
01:05:50 I'm going to double-click on it to call it "flips colon zero." This is what I want it to look like when my UI first launches.
01:05:57 Now here, I'm never going to be tapping on this and causing a message to be sent like the button; it's the other way around.
01:06:04 My controller wants to talk to this and tell it when the flips changes all the time.
01:06:08 Okay? So you might think that you would drag from your code down to this flips, but unfortunately you don't do that.
01:06:15 You still hold down control and drag from here.
01:06:19 But instead of dragging it down into your implementation area, you drag it into the interface area because you're going to create a property that connects to that label basically.
01:06:28 So we do that.
01:06:29 We get a thing here.
01:06:30 It's asking us a little bit different questions: "What's the name of this property?" I'm going to call it "flips label." Okay? Notice that this property is weak.
01:06:38 Okay? When I click connect, it's going to make a property here and it's going to be weak.
01:06:43 This is the first time we've seen weak versus strong.
01:06:46 The reason this is weak is because this label is held strongly by the view itself.
01:06:53 So we don't need to have a strong pointer to it, to keep it in the heap.
01:06:56 The view will.
01:06:57 And if this label ever leaves the view, it will get cleaned out from the heap.
01:07:02 And this property -- this pointer to it -- will get set to nil, which is exactly what we want.
01:07:06 Because if that flips label's not in the view, we don't want to be updating it and sending messages to it.
01:07:11 So it's a great use of weak right here.
01:07:15 This is normal property that you're used to except for maybe this IB outlet.
01:07:19 That's just like IB action.
01:07:21 It's a meaningless thing the compiler ignores that Xcode is using.
01:07:26 Okay? So that it can do this -- show you what it's connected to when you mouse over it.
01:07:31 Okay? By the way, you can see all the connections by also right-clicking on things.
01:07:36 So here I just right-clicked on the button and you can see its connections.
01:07:40 If you ever want to rename -- like if I don't like touch card button, I want to rename it to something, you can't just rename unfortunately.
01:07:47 You have to go in here, right-click, use this little thing to disconnect it, and then control drag again.
01:07:55 Okay? Everybody got that?
01:07:57 It's unfortunate.
01:07:58 It would be really nice if Xcode could track that for you but it can't.
01:08:00 So if you ever want to rename something, you have to disconnect it here by right-clicking on it, and then control drag a new one and set the name that way.
01:08:10 You can also right-click on this little guy and it will show you all the connections for your controller.
01:08:16 Brings up this window.
01:08:17 And I can see the label.
01:08:18 You see? I'm mousing over the button.
01:08:21 Label. There's also this little property here, which is something you haven't seen, which is basically a property that points to the entire view from your controller.
01:08:29 So this is the connections to your controllers.
01:08:31 See, it says "card game view controller"?
01:08:33 Okay? So that's right-clicking.
01:08:35 I'm right-clicking over here.
01:08:37 All right.
01:08:38 So how are we going to make this flips label work?
01:08:40 We are going to put it aside for a second.
01:08:45 Let's not think about it.
01:08:46 Let's instead do another property.
01:08:49 Property. Which is nonatomic, which is just going to be an int, which I'm going to call "flip count." Okay? So flip count is just an integer that's going to keep the count of flips.
01:09:02 And watch this.
01:09:05 Some more space here.
01:09:06 Go there. I'm just going to go down here and say self.flip count plus plus.
01:09:14 Okay? Now, does that call the setter or the getter for flip count?
01:09:20 Both. Exactly.
01:09:21 That is calling both the setter and the getter.
01:09:23 It's calling the getter to get the flip count, then it's plus plussing it; and then it's calling the setter to set it back.
01:09:29 Okay. So that's kind of a funky lining of code right there.
01:09:32 That's the same as saying self.flip count equals self.flip count plus one.
01:09:34 So it's calling the getter and the setter.
01:09:36 Okay. So now we've got this nice flip count.
01:09:39 It's keeping track of the count; how do we hook that up to this thing over here?
01:09:43 Which I'm going to make a little bigger, by the way.
01:09:45 Okay. How do we hook that up so that says flips colon one, flips colon two, flips colon three?
01:09:50 Well, we're going to do it using the setter for flip count.
01:09:57 Okay? So normally a setter for flip count would look like this.
01:10:00 Okay? And here's another great use of setters and getters, which is to keep UI in sync with a property.
01:10:08 And I'll just do this by saying self.flips label -- flips label.text equals -- oops, sorry.
01:10:18 It's hard to type standing up.
01:10:20 Equals NS string, string with format, which you've seen before, flips colon percent D self.flip count.
01:10:30 Okay? So now every time flip count is changed we're going to update the UI.
01:10:35 Make sense?
01:10:36 Any questions about that?
01:10:39 Okay. So let's run.
01:10:45 Okay. Here's our thing.
01:10:45 So click, flips over, flip count updates.
01:10:49 Flip, flip, flip, flip.
01:10:50 Back and forth working, and the flip count is keeping track of how many flips we're doing.
01:10:54 Okay? So you can see this stuff is really simple to wire up.
01:10:58 Okay? And, you know, when you get into building even complicated applications, because you're always going to use these same mechanisms with target action and outlets and you're going to be using setters and getters to keep things in sync, it's going to be easy for people to understand how your code works.
01:11:11 They know where to look to see where UI updating happens, etc. I'm going to do one other thing here.
01:11:17 Take a minute and show you NS log.
01:11:19 Okay. I told you that you could log something in the console.
01:11:22 So let's do every time this thing changes, let's do an NS log.
01:11:25 So it's just a C function.
01:11:27 And you give it a format string like printf.
01:11:29 So I'll say flip count equals percent V self.flip count.
01:11:36 Okay? So you just put that NS log in there, and now when we run you're going to see it in the console.
01:11:42 It's going to come up when I click, and it's going to say what happened here.
01:11:45 By the way, of course, I can make that wider.
01:11:48 And go back to the simulator.
01:11:52 Let's see.
01:11:53 Okay. So NS logging -- awesome way to debug.
01:11:57 Okay? Sometimes a lot easier than setting a breakpoint and then when you get there looking at the variables and stuff.
01:12:01 It just prints out what's going on and you can watch it.
01:12:03 Especially in the UI things are sometimes animated, they're happening over time.
01:12:07 It's sometimes hard to set a breakpoint in the middle of an animation to see what's going on.
01:12:11 But if you do some NS logs, you can kind of see how things progress.
01:12:14 All right.
01:12:14 The last thing I'm going to show you here is how to add a new class to your app because you're going to need to do that.
01:12:21 You're going to add four classes to this.
01:12:22 Okay? You're going to start with this, okay, and then you're going to add four classes -- card, deck, etc. And the way you add a class is you -- and in fact, the way you add any file to your project -- is you go to the file menu, new file.
01:12:41 Okay? And there's all different kinds of things you can add here, database file, schema files and everything.
01:12:46 But you want this one top-left Objective-C class.
01:12:51 Okay? Here you're just going to type the name of the class.
01:12:53 So for example, if I'm going to add card and the name of the superclass.
01:12:58 Okay. If you are doing playing card, you can type card here.
01:13:01 It doesn't have to be something that's chosen from this list, okay, which are the iOS ones.
01:13:05 So here I'm going to make card.
01:13:08 I could put card right here.
01:13:09 It's asking where to store this.
01:13:10 I could put it right in the same place that my card game controller is, you see?
01:13:15 But I'm actually a big fan of putting your model in its own directory.
01:13:20 So you would use new folder down here.
01:13:23 Let's create like a model directory, and that creates a model directory here.
01:13:28 There's a controller, here's the model directory.
01:13:31 And so create.
01:13:32 So that's going to create card dot H and M. Here's card dot H and M, okay, kind of blank versions of them.
01:13:39 You can switch back and forth between them here.
01:13:41 Notice that if I switch the left, the right changes to match.
01:13:44 You see? Change this, this matches.
01:13:47 That's because I have counterparts chosen right here.
01:13:49 If you go to manual and pick this file manually, then it won't be doing that magic anymore.
01:13:54 But you can always go back to counterparts and it will keep them in sync.
01:13:57 Okay. So you can have -- some people like their header file on the left, some on the right, whatever.
01:14:02 Also, notice over here it would be nice if I can also group these things in the navigator.
01:14:07 And I can by having them selected right-click new group.
01:14:12 Say model.
01:14:13 Right here.
01:14:14 And now I've put my model in its own little place right here.
01:14:17 I can even move this around, put it down here, whatever.
01:14:20 I could put all my four classes in there.
01:14:22 It is possible to link this group to the file system.
01:14:27 In fact, if you just click on a file and bring up the inspector on it right here, you can see that it's got this location where you can specify whether it's an absolute path, or relevant to the group it's in, or whatever.
01:14:38 So you can control that.
01:14:41 And that's it.
01:14:42 So I think that's all you need to do your homework.
01:14:44 You're just going to type in all your code here for card and add your three other ones.
01:14:48 Type all that code in.
01:14:49 And then all you got to do is make that card instead of showing ace of clubs all the time, needs to go through the deck, okay?
01:14:55 There's a detailed homework write up posted.
01:14:58 It has all kinds of hints and help, and tells you about what the required tasks are, and evaluation criteria, and all that stuff.
01:15:04 So definitely read that thing in detail, okay?
01:15:07 Don't skip that stuff and just try to go straight to doing it.
01:15:09 And if you have questions, I'll be here.
01:15:11 That's it.
01:15:13 >> For more, please visit us at Stanford.edu.
			</span></pre>
		</div>
	</div>
	<!-- Lecture 2 END -->

<!-- Container block end -->
</div>

<ul>
<li>
	<h4>Lecture 3. Objective-C</h4>
	<a href="Lecture 3 Slides.pdf">Slides</a>
	<a href="http://a514.phobos.apple.com/us/r30/CobaltPublic4/v4/6f/43/c0/6f43c09a-be53-8faf-7682-7e80f33a715d/306-7553620539362248945-03_9_30_13_Mon_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 4. Foundation and Attributed Strings</h3>
	<a href="Lecture 4 Slides.pdf">Slides</a>
	<a href="http://a1321.phobos.apple.com/us/r30/CobaltPublic4/v4/41/4d/50/414d50bc-7759-08f4-253d-9a369d036ac6/307-7537343365394160208-04_10_02_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 5. View Controller Lifecycle</h3>
	<a href="Lecture 5 Slides.pdf">Slides</a>
	<a href="http://a1450.phobos.apple.com/us/r30/CobaltPublic6/v4/e6/22/ab/e622abcd-e006-1007-1b64-70ee030ea76d/329-1369435774421816233-05_10_07_13_Mon720p1500.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 6. Polymorphism with Controllers, UINavigation, UITabBar</h3>
	<a href="Lecture 6 Slides.pdf">Slides</a>
	<a href="http://a598.phobos.apple.com/us/r30/CobaltPublic6/v4/84/42/2b/84422b0b-4d1a-9e11-7a13-2cba614ca0f4/320-57290735612236135-06_10_09_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 7. Views and Gestures</h3>
	<a href="Lecture 7 Slides.pdf">Slides</a>
	<a href="http://a1092.phobos.apple.com/us/r30/CobaltPublic/v4/af/03/9a/af039a4b-927b-31bd-43b5-16a105e6646a/335-3332520951512004909-07_10_14_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 8. Protocols, Blocks, and Animation</h3>
	<a href="Lecture 8 Slides.pdf">Slides</a>
	<a href="http://a1983.phobos.apple.com/us/r30/CobaltPublic6/v4/10/04/39/100439be-3a03-c487-091a-f272129bedf2/321-6070172648747410728-08_10_21_13_Mon_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 9. Animation and Autolayout</h3>
	<a href="Lecture 9 Slides.pdf">Slides</a>
	<a href="http://a83.phobos.apple.com/us/r30/CobaltPublic/v4/af/31/42/af3142be-94d6-e74e-f68b-3f8af2074e8b/301-1439599184527015231-09_10_23_13_Wed_720p1500cc_2.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 10. Multithreading, Scroll View</h3>
	<a href="Lecture 10 Slides.pdf">Slides</a>
	<a href="http://a323.phobos.apple.com/us/r30/CobaltPublic4/v4/3c/0c/2a/3c0c2a9d-1b6b-f3ff-87e8-542dcc0b6961/313-693605880565847287-10_10_28_13_Mon_720p1500cc_good.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 11. Table View and iPad</h3>
	<a href="Lecture 11 Slides.pdf">Slides</a>
	<a href="http://a1323.phobos.apple.com/us/r30/CobaltPublic6/v4/bb/87/37/bb8737f6-7375-9f44-eef7-dbd52a5764dc/336-7131778052599239043-11_10_30_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 12. Documents and Core Data</h3>
	<a href="Lecture 12 Slides.pdf">Slides</a>
	<a href="http://a384.phobos.apple.com/us/r30/CobaltPublic/v4/b0/ff/77/b0ff7714-acb5-d85a-b60e-94e2b7904d60/335-6855286695127934476-12_10_04_13_Mon_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 13. Core Data and Table View</h3>
	<a href="Lecture 13 Slides.pdf">Slides</a>
	<a href="http://a98.phobos.apple.com/us/r30/CobaltPublic/v4/8a/6b/5e/8a6b5e38-6b4a-cea4-5e63-f8ad3c526657/301-626459091908064337-13_11_06_13_Wed_rev720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 14. UIApplication, Network Activity Indicator, and Maps</h3>
	<a href="Lecture 14 Slides.pdf">Slides</a>
	<a href="http://a793.phobos.apple.com/us/r30/CobaltPublic4/v4/1b/a3/73/1ba3735a-6d41-ba0a-2ab7-1fa288dbe243/323-7005605569977620519-14_11_11_13_Mon_720pccREV2.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 15. MapKit and Embed Segue</h3>
	<a href="Lecture 15 Slides.pdf">Slides</a>
	<a href="http://a1113.phobos.apple.com/us/r30/CobaltPublic6/v4/4b/40/12/4b4012c7-e4aa-9d46-cf6c-3b73917d2c60/329-3391004715910185574-15_11_13_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 16. Modal Segues, Text Fields, Alerts, and Action Sheets</h3>
	<a href="Lecture 16 Slides.pdf">Slides</a>
	<a href="http://a597.phobos.apple.com/us/r30/CobaltPublic6/v4/d1/62/c6/d162c695-7a8c-9197-3959-b4b3e2596735/327-4265577748290961697-16_11_18_13_Mon_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 17. Camera, Core Motion, Application Lifecycle</h3>
	<a href="Lecture 17 Slides.pdf">Slides</a>
	<a href="http://a608.phobos.apple.com/us/r30/CobaltPublic4/v4/63/ed/b9/63edb950-8002-08d9-152c-d5116b768a03/314-230466945516606221-17_11_20_13_Wed_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
<li>
	<h3>Lecture 18. Localization, Adding UI to Settings</h3>
	<a href="Lecture 18 Slides.pdf">Slides</a>
	<a href="http://a647.phobos.apple.com/us/r30/CobaltPublic6/v4/8b/55/84/8b558456-b30d-0959-37ea-832e6478e963/317-3373745886146434024-18_12_02_13_Mon_rev_720p1500cc.mp4">Video</a>
	<p>
		Class Logistics, Overview of iOS, MVC, Objective-C
	</p>
</li>
</ul>

</body></html>